<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>usg的blog</title>
  
  <subtitle>侦查鸡的天空</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.dgut.top/"/>
  <updated>2021-05-18T06:24:08.947Z</updated>
  <id>https://blog.dgut.top/</id>
  
  <author>
    <name>usg-cn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HBS数据备份</title>
    <link href="https://blog.dgut.top/2021/05/14/HBS%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/"/>
    <id>https://blog.dgut.top/2021/05/14/HBS%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</id>
    <published>2021-05-14T02:27:03.000Z</published>
    <updated>2021-05-18T06:24:08.947Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140345.png" alt="image-20210514102750088"></p><blockquote></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140346.png" alt="image-20210514102842412"></p><h1 id="HBS-3给你的NAS的数据做个备份"><a href="#HBS-3给你的NAS的数据做个备份" class="headerlink" title="HBS 3给你的NAS的数据做个备份"></a>HBS 3给你的NAS的数据做个备份</h1><p>随着数据越来越多，需要的空间也越来越大，同时为了高效地管理数据和兼顾数据的安全，我在去年年底在某鱼购入了一台有NAS品牌商生产的<code>qnap 453b mini</code> 这款NAS虽然是<code>453d mini</code>的上一代产品，但是它的性能和扩展性也足够了。但是NAS买回来没有第一时间用起来，而是在一角默默躺着吃灰。最近也是搬了新家才将其带到新家重新利用起来的。</p><p>现在NAS被我东拼西凑出3块硬盘分别是2块2T的希捷+1块1T的WD蓝盘，这2块2T的硬盘组成了一个4T的硬盘阵列，RAID1拥有2倍数的读取写入速度但是安全性也打了折扣–任何一块硬盘出故障了都会导致整个硬盘阵列数据全部丢失。这个4T的阵列中储存了很多我旅行、参观、生活、工作和家人们的照片，除此之外还有利用<code>Qsync</code>备份的工作文档，林林总总。反正现在就是担心这些珍贵数据的安全，提前做好重要数据资料的备份。</p><p>毕竟..数据无价…..</p><p>在查询了众多资料之后我找到了威联通套件中心的<code>HBS3备份与同步中心</code> 利用这个玩意就可以轻而易举地构建你的数据安全堡垒了！！</p><h1 id="威联通的数据安全备份管家：HBS3"><a href="#威联通的数据安全备份管家：HBS3" class="headerlink" title="威联通的数据安全备份管家：HBS3"></a>威联通的数据安全备份管家：HBS3</h1><blockquote><p>是数据备份和恢复的终极存储解决方案。HBS 将数据备份、恢复和同步功能融合到一个易于使用的紧凑界面中。HBS 可处理 QNAP NAS 设备、远程服务器和常见云存储提供商的数据，是灾难恢复计划的理想选择。</p></blockquote><p>HBS 3 是 Hybrid Backup sync 3 的缩写，意为混合型备份与同步中心，主要是将数据备份、复原、同步等功能整合到单一 QTS 应用中，让您可轻松将 QNAP NAS 中的数据备份或同步到另一台 QNAP NAS、远程<a href="https://www.smzdm.com/fenlei/fuwuqi/" target="_blank" rel="noopener">服务器</a>或云端备份空间中。重复数据删除 (QuDedup) 技术可加速多版本备份效率，节省带宽及存储空间。当意外发生时，HBS 3 更协助您迅速复原档案，万无一失。</p><p>主要有三种方式：</p><p>1、备份</p><p>HBS 3 帮助您有效率地备份文件至本地端 NAS、外接装置 (USB 一键启动备份功能)、远程服务器或云端存储空间中；多版本备份机制，确保重要数据妥善保存，更可让您便利追踪修改纪录。</p><p>2、还原</p><p>当意外发生或资料遗失时，您可实时从本地端 NAS、外接装置、远程服务器或云端存储空间选择您想回复的档案版本迅速还原档案。</p><p>3、同步</p><p>您可选择将 QNAP NAS 上的档案单向同步至本地端 NAS 或外接装置；透过RTRR、Rsync、FTP、CIFS/SMB协议单向或双向同步远程NAS或服务器的档案；单向或双向同步云端空间的档案。</p><p>（以上摘自官网）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140347.png" alt="image-20210514104836792"></p><p>(支持多平台备份–不过这里只用到本机备份)</p><p>HBS3提供了一个全方位数据备份及灾害复原的计划，但是也强调了“没有一个备份计划是完美的”…</p><p>目前广为接受的 3-2-1 备份策略：3 份副本、2 种不同备份媒体、1 个异地存储…</p><p>多做一个备份当然多一份保障….</p><h1 id="1-HBS3安装"><a href="#1-HBS3安装" class="headerlink" title="1.HBS3安装"></a>1.HBS3安装</h1><p>安装HBS3简直太简单了，打开套件中心找到<code>HBS3</code>就可以安装了，一路点NEXT，小伙伴们应该很快就能安装好了，这里我就不废话了。。。。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140348.png" alt="image-20210514113750057"></p><h1 id="2-HBS3本地备份"><a href="#2-HBS3本地备份" class="headerlink" title="2.HBS3本地备份"></a>2.HBS3本地备份</h1><p>这里我希望的是将4T的那个存储阵列中有需要的数据（大约500G）周期保存到那个1T的WD蓝盘，显然于冷备份，首先是打开HBS3套件，创建备份作业</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140349.png" alt="image-20210514114330481"></p><p>在跳转后的选项卡中选择<code>新备份作业</code></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140350.png" alt="image-20210514114631514"></p><p>这里选择需要的文件夹，我选中了我的照片、视频和工作文件夹，选中后选择下一步</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140351.png" alt="image-20210514114735051"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140352.png" alt="image-20210514114836102"></p><p>选择本地NAS，这里要根据你的喜好来，HBS3还提供了众多云服务选项，有阿里云（应该是对象存储）、腾讯云、Google drive、华为云、OneDrive等选择，应有尽有。小伙伴们按照需求选择即可。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140353.png" alt="image-20210514115021584"></p><p>选择完本地NAS之后，接下来要选备份的目标文件夹了，我选择到那个蓝盘的备份目录。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140354.png" alt="image-20210514115127521"></p><p>接下来就可以开始数据备份了，源文件夹和目标文件夹都选好了，检查一下，没有错误就点击右下角 下一步 ..</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140355.png" alt="image-20210514115215817"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140356.png" alt="image-20210514115319526"></p><p>选择备份计划这里可以选择一个备份周期，我选择了每周三晚上3：00夜深人静的时候自己完成备份更新，这样就是只要我的照片或者数据更新了之后<code>HBS3</code>就会在每个星期三的晚上3：00把新的数据备份到蓝盘这个备份了。这个计划随时可以更改，好评！</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140357.png" alt="image-20210514115819326"></p><p>其中还有版本控制，这里我先不启用，小伙伴可以按需启动。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140358.png" alt="image-20210514115918424"></p><p>来到“规则”设置页面，在 “方式 ”里，这里我选择的是不应用筛选器….</p><p>下面默认是勾选使用QuDedup，这个是去重复备份功能….默认设置就好…</p><p>在策略里，可以选择是否加密备份….</p><p>注意下来的“将删除的数据从目标中移除”一项，如果选择了，那么源文件夹里删除的文件，目标文件夹也会一并在备份中删除的哦…..去掉勾选就相当于增量备份（这样我的照片只负责增加）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140359.png" alt="image-20210514120026602"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140400.png" alt="image-20210514120109637"></p><p>现在就能在作业选项卡看到目前正在进行着的数据备份作业了</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140401.png" alt="image-20210514133409629"></p><p>默默等待备份完成即可</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140402.png" alt="image-20210514134815719"></p><p>在输出文件夹也就是我的WD蓝盘中会同步出现一个<code>.qdff</code>后缀的文件，这个就是威联通QTS系统中的备份文件，这个文件就是以后数据的恢复用的。</p><h1 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h1><p>数据的恢复也相当简单，相当于备份的逆操作，只需在<code>HBS3</code>中选择恢复，选择到之前的备份，再设置好要恢复到的目录就可以了。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140403.png" alt="image-20210514134534418"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这是我的第一篇关于NAS的文章，虽然QTS和DSM系统都深度使用过，但是还是第一次详细地记录了整个操作的过程，发现网络上对QTS系统的教学不是很多，相关视频更是少之又少，希望能对大家起到帮助。</p><p>威联通系统的<code>HBS3</code>备份中心的使用还是很简便的，整个过程下来没有遇到任何一点阻碍，虽然还有很多的功能比如说同步、恢复的功能没有实践过，（这些可以留到日后）。HBS3还是很强大的。</p><p>好了今天先到这里了，日后再分享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210514140345.png&quot; alt=&quot;image-2021051410275
      
    
    </summary>
    
    
    
      <category term="qnap" scheme="https://blog.dgut.top/tags/qnap/"/>
    
  </entry>
  
  <entry>
    <title>frp内网穿透</title>
    <link href="https://blog.dgut.top/2021/04/27/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://blog.dgut.top/2021/04/27/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2021-04-27T06:36:53.000Z</published>
    <updated>2021-04-29T01:53:50.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Frp内网穿透–在公网访问局域网资源"><a href="#Frp内网穿透–在公网访问局域网资源" class="headerlink" title="Frp内网穿透–在公网访问局域网资源"></a>Frp内网穿透–在公网访问局域网资源</h1><blockquote><p><a href="https://gofrp.org/docs/setup/" target="_blank" rel="noopener">frp文档</a></p><p><a href="https://github.com/fatedier/frp/releases/tag/v0.36.2" target="_blank" rel="noopener">GitHub</a></p></blockquote><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>上传frp到你的服务器’<code>root</code>‘目录</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210429094111.png" alt="image-20210427145106237"></p><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><p>修改<code>frps.ini</code> 配置文件，因为我们服务器上运行的是<code>frps</code>服务端，所以我们需要修改一下服务端的配置文件，怎么配置fprs其实康康官方文档就好了：<a href="https://github.com/fatedier/frp#development-status" target="_blank" rel="noopener">链接</a></p><p>最简约的其实就只有一行（如下）</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">＃ frps.ini </span><br><span class="line">[<span class="meta">common</span>] </span><br><span class="line"><span class="keyword">bind_port </span>= <span class="number">7000</span></span><br></pre></td></tr></table></figure><p>当然这里有一些推荐的配置（比如说一个数据展示页面）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span> = admin123456</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="comment"># dashboard的用户名和密码均为可选，如未设置，默认为admin。</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin</span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210429094112.png" alt="image-20210427152028280"></p><p>指定了一个默认<code>7000</code>端口</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210429094113.png" alt="image-20210427145741303"></p><p>防火墙中放行相应的<code>7000</code>和<code>7500</code>端口</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210429094114.png" alt="image-20210427151532058"></p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>先进入到刚刚上传的<code>frp</code>目录</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/root/frp</span></span><br></pre></td></tr></table></figure><ol><li><code>frps</code>在服务器A上启动：就可以看到frps服务端开始进行了</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./frps</span> -c <span class="string">./frps.ini</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210429094115.png" alt="image-20210427154653358"></p><p>（但是现在运行的是在前台模式，现在要把它运行在后台）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./frps -c frps.ini &gt;/dev/<span class="literal">null</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><blockquote><p>后台运行frp服务</p><pre><code>服务端： nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp;客户端： nohup ./frpc -c frpc.ini &gt;/dev/null 2&gt;&amp;1 &amp; 说明：&gt;/dev/null 2&gt;&amp;1 &amp;，表示丢弃。</code></pre><p>2.停止<br>先找到这个进程</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux|grep frp| grep -v grep</span><br><span class="line"></span><br><span class="line">root      <span class="number">3600</span>  <span class="number">0.1</span>  <span class="number">0.1</span> <span class="number">110188</span>  <span class="number">9484</span> pts/<span class="number">0</span>    Sl   <span class="number">15</span>:<span class="number">04</span>   <span class="number">0</span>:<span class="number">00</span> ./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure><p>执行之后如果显示这样则成功了</p><p>然后kill -9 进程号</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill <span class="number">-9</span> <span class="number">3600</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h2><p>访问linux的自启动目录表</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">frps</span>.<span class="title">service</span></span></span><br></pre></td></tr></table></figure><p>按键盘 <code>i</code>插入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="attribute">Description</span>=frps service</span><br><span class="line"><span class="attribute">After</span>=network.target syslog.target</span><br><span class="line"><span class="attribute">Wants</span>=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"><span class="attribute">Type</span>=simple</span><br><span class="line"><span class="comment">#启动服务的命令（此处写你的frps的实际安装目录）</span></span><br><span class="line"><span class="attribute">ExecStart</span>=/root/frp/frps -c /root/frp/frps.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"><span class="attribute">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>按 <code>Esc</code>输入<code>:wq</code>退出保存</p><p>开启自启</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="builtin-name">enable</span> frps</span><br></pre></td></tr></table></figure><p>重启服务器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">reboot</span></span><br></pre></td></tr></table></figure><p>这样就完成了自启动的设置了</p><p>查看日志</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl status frps</span></span><br></pre></td></tr></table></figure><p>这样服务端的所有配置都完成了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Frp内网穿透–在公网访问局域网资源&quot;&gt;&lt;a href=&quot;#Frp内网穿透–在公网访问局域网资源&quot; class=&quot;headerlink&quot; title=&quot;Frp内网穿透–在公网访问局域网资源&quot;&gt;&lt;/a&gt;Frp内网穿透–在公网访问局域网资源&lt;/h1&gt;&lt;blockquo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>短信转发</title>
    <link href="https://blog.dgut.top/2021/04/26/%E7%9F%AD%E4%BF%A1%E8%BD%AC%E5%8F%91/"/>
    <id>https://blog.dgut.top/2021/04/26/%E7%9F%AD%E4%BF%A1%E8%BD%AC%E5%8F%91/</id>
    <published>2021-04-26T03:33:57.000Z</published>
    <updated>2021-04-26T03:33:57.754Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AD再见</title>
    <link href="https://blog.dgut.top/2021/04/21/AD/"/>
    <id>https://blog.dgut.top/2021/04/21/AD/</id>
    <published>2021-04-21T01:29:58.000Z</published>
    <updated>2021-04-26T00:19:24.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AdGuardHome神器"><a href="#AdGuardHome神器" class="headerlink" title="AdGuardHome神器"></a>AdGuardHome神器</h1><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421152731.png" alt="image-20210421152729678"></p><p>最近拿到了NanoPi R4S 开发板作为一个软路由，以前也是陆陆续续学习了搭建openwrt的一些方法，正好拿到了新的硬件，正好来研究一下。最近发现网络中的广告越来越多了，所以就想利用openwrt里部署的AdGuard Home作为一个dns网关，帮我们去除网络中烦人的“牛皮癣”。</p><p>NanoPi R4S 开发板的全名是高性能边缘计算路由器R4S，这款开发板具有2个千兆以太网网口，一个是SoC引出，另外一个是由PCle转接。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142843.jpg" alt="img"></p><p>SoC用的是RK3399作为主控，主频1.8GHz，板载1G或者4G 内存，2个USB3.0接口可接USB WIFI、储存设备，保证了性能和扩展性。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142936.jpg" alt="img"></p><p>官方开发文档在这：（<a href="http://wiki.friendlyarm.com/wiki/index.php/NanoPi_R4S" target="_blank" rel="noopener">链接</a>）</p><p>装好openwrt系统就可以开始了（<a href="https://github.com/QiuSimons/R2S-R4S-X86-OpenWrt" target="_blank" rel="noopener">系统链接</a>）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142853.png" alt="image-20210421093019026"></p><p>在系统–软件包–安装好<a href="https://github.com/AdguardTeam/AdGuardHome" target="_blank" rel="noopener">AdGuardHome</a>就可以进行下一步的配置了</p><p>AdGuardHome的官方<a href="https://adguard.com/zh_cn/adguard-home/overview.html" target="_blank" rel="noopener">主页</a></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142900.png" alt="image-20210421094757658"></p><p>以下是AdGuardHome的描述</p><blockquote><h3 id="AdGuardHome您和您的设备的隐私保护中心"><a href="#AdGuardHome您和您的设备的隐私保护中心" class="headerlink" title="AdGuardHome您和您的设备的隐私保护中心"></a>AdGuardHome您和您的设备的隐私保护中心</h3><p>免费和开源，功能强大的全网络广告和跟踪器阻止了DNS服务器。</p><p>AdGuard Home是用于阻止广告和跟踪的全网络软件。设置完成后，它将涵盖您所有的家用设备，并且您不需要任何客户端软件。</p><p>它作为DNS服务器运行，将跟踪域重新路由到“黑洞”，从而防止您的设备连接到这些服务器。它基于我们用于公共<a href="https://adguard.com/en/adguard-dns/overview.html" target="_blank" rel="noopener">AdGuard DNS</a>服务器的软件-两者共享许多通用代码。</p></blockquote><p>重的来说AdGuardHome的优点：</p><ol><li>局域网一次部署，所有客户端都生效</li><li>无需手机端ad排除软件的耗电和降低性能</li><li>可以和其他代理共存</li><li>高性能，RK3399性能不是盖的</li></ol><p>好的 废话不多说开始安装</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>点击更新，第一次更新会安装AdGuardHome所需要的引擎核心，现在等它更新好就行了。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142907.png" alt="image-20210421095710947"></p><p>更新好了启动AdGuardHome，点击保存点击那个绿色的图标或者访问你的管理ip加上:3000端口就可以访问到AdGuardHome的后台了。</p><p>点击【开始配置】</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142913.png" alt="image-20210421100510762"></p><ol><li>网页后台管理界面默认是80端口，可以改为3000端口，这样我们在刚刚那个openwrt界面点击按钮就可以进入了。</li><li>DNS服务器端口默认是53但是已经被占用了，现在改为533（要记得喔，下面会用上的）。</li><li>点击下一步</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142937.png" alt="image-20210421100938556"></p><p>创建登录账户和密码 </p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142938.png" alt="image-20210421102223064"></p><p>点击下一步</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142939.png" alt="image-20210421102259191"></p><p>到这就安装完成了，接下来可以进行配置了</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>接着回到openwrt的界面会发现状态显示<strong><em>AdGuardHome 运行中***</em></strong>未重定向***，这里是因为还没将你的dns服务器重定向到AdGuardHome核心。</p><h2 id="openwrt设置"><a href="#openwrt设置" class="headerlink" title="openwrt设置"></a>openwrt设置</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142940.png" alt="image-20210421102703249"></p><ol><li>点击533重定向复选框</li><li>选择重定向53端口到AdGuardHome</li><li>保存应用</li></ol><p>就会发现状态提示<strong><em>AdGuardHome 运行中***</em></strong>已重定向***</p><p>这样就完成重定向了。</p><h2 id="AdGuardHome-DNS设置"><a href="#AdGuardHome-DNS设置" class="headerlink" title="AdGuardHome-DNS设置"></a>AdGuardHome-DNS设置</h2><p>用你刚刚设置好的账户和密码登录后台比如说我的AdGuardHome后台就是<a href="http://192.168.1.1:3000，登录完成点击设置--DNS设置">http://192.168.1.1:3000，登录完成点击设置--DNS设置</a></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142941.png" alt="image-20210421102418299"></p><ol><li>复制下方DNS列表到在上游DNS服务器文本框</li><li>填写Bootstrap DNS 服务器列表</li><li>选择并行请求</li><li>应用</li><li>测试上游DNS</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">上游DNS服务器列表</span><br><span class="line"></span><br><span class="line"><span class="number">119.29</span><span class="number">.29</span><span class="number">.29</span></span><br><span class="line"><span class="number">1.2</span><span class="number">.4</span><span class="number">.8</span></span><br><span class="line"><span class="number">101.226</span><span class="number">.4</span><span class="number">.6</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//114.114.114.114</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//223.5.5.5</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//223.6.6.6</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//8.8.4.4</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//202.14.67.4</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//202.14.67.14</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//202.130.97.65</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//202.130.97.66</span></span><br><span class="line"><span class="symbol">tcp:</span><span class="comment">//168.95.192.1</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//1.1.1.1/dns-query</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//1.0.0.1/dns-query</span></span><br><span class="line"><span class="symbol">tls:</span><span class="comment">//8.8.8.8</span></span><br><span class="line"><span class="symbol">tls:</span><span class="comment">//8.8.4.4</span></span><br><span class="line"><span class="symbol">tls:</span><span class="comment">//dns.google:853</span></span><br></pre></td></tr></table></figure><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap DNS 服务器列表</span><br><span class="line"></span><br><span class="line"><span class="number">219.141.136.10</span>（北京电信）</span><br><span class="line"><span class="number">219.141.140.10</span>（北京电信）</span><br><span class="line"><span class="number">202.96.199.133</span>（上海电信）</span><br><span class="line"><span class="number">119.29.29.29</span></span><br><span class="line"><span class="number">223.5.5.5</span></span><br><span class="line"><span class="number">180.76.76.76</span></span><br><span class="line"><span class="number">8.8.8.8</span></span><br><span class="line"><span class="number">8.8.4.4</span></span><br><span class="line"><span class="number">208.67.222.222</span></span><br></pre></td></tr></table></figure><p>看到提示的指定的DNS测试通过就行了，不行的话再根据提示的某个服务器去掉就行了。例如提示1.1.1.1这个服务器不通过的话就在上面的DNS服务器文本框中去掉就行了。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142942.png" alt="image-20210421103706416"></p><p><strong>Bootstrap DNS 服务器列表</strong>可以参考你openwrt概览那你的网络状况的本地DNS情况填入。像我比较懒的，就直接填写宽带拨号获取的DNS了</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142943.png" alt="image-20210421104556157"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142944.png" alt="image-20210421104724173"></p><p>完成这步，DNS服务器就算设置成功了，接下来趋势设置AdGuardHome的重头戏：广告过滤功能！</p><h2 id="AdGuardHome–广告过滤"><a href="#AdGuardHome–广告过滤" class="headerlink" title="AdGuardHome–广告过滤"></a>AdGuardHome–广告过滤</h2><p>点击 过滤器–DNS封锁清单添加下方合适的规则并将对应规则打钩</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142945.png" alt="image-20210421104231396"></p><ol><li><p>点击添加阻止的列表–添加一个自定义列表</p></li><li><p>填入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名称：ADGuard规则</span><br><span class="line">URL：https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/privacy-protection-tools/</span>anti-AD<span class="regexp">/master/</span>anti-ad-easylist.txt</span><br></pre></td></tr></table></figure></li><li><p>不需要填写入多，如果需要的话还有这些，已经够用了</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AdAway，<span class="symbol">https:</span>/<span class="regexp">/adaway.org/hosts</span>.txt</span><br><span class="line">乘风 视频，<span class="symbol">https:</span>/<span class="regexp">/gitee.com/xinggsf</span><span class="regexp">/Adblock-Rule/raw</span><span class="regexp">/master/mv</span>.txt</span><br><span class="line">乘风 广告，<span class="symbol">https:</span>/<span class="regexp">/gitee.com/xinggsf</span><span class="regexp">/Adblock-Rule/raw</span><span class="regexp">/master/rule</span>.txt</span><br><span class="line">My AdFilters，<span class="symbol">https:</span>/<span class="regexp">/gitee.com/halflife</span><span class="regexp">/list/raw</span><span class="regexp">/master/ad</span>.txt</span><br><span class="line">隐私相关</span><br><span class="line">CJX<span class="string">'s uBlock list，https://gitee.com/cjx82630/cjxlist/raw/master/cjx-ublock.txt</span></span><br><span class="line"><span class="string">EasyPrivacy，https://easylist-downloads.adblockplus.org/easyprivacy.txt</span></span><br><span class="line"><span class="string">I don'</span>t care about cookies，<span class="symbol">https:</span>/<span class="regexp">/www.i-dont-care-about-cookies.eu/abp</span><span class="regexp">/</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>保存–打勾启用</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142946.png" alt="image-20210421105326939"></p><p>这样就完成了ADGuard的设置了。</p><p>接下来回到openwrt设置DNS转发（最后一部分了别急）</p><h3 id="openwrt-DNS转发"><a href="#openwrt-DNS转发" class="headerlink" title="openwrt DNS转发"></a>openwrt DNS转发</h3><ol><li>网络——DHCP/DNS——服务器设置——基本设置</li><li>找到【DNS转发】点击添加2个，把之前设置的那个ADGuard服务器地址和端口号填上去（之前设置的是192.168.2.1:533和127.0.0.1:533）ps：这里要把端口的 ’:‘ 改为 ‘#’ 填进去</li><li>保存应用</li></ol><p>这样就完成了所有配置的过程了。可以愉快的上网了。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142947.png" alt="image-20210421110031298"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>配置完之后就可以回到AdGuardHome的仪表盘了。可以直观地看到拦截的效果了。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421142948.png" alt="image-20210421142831927"></p><p>可以见到，局域网广告防护已经开始，并且生效了！</p><p>enjoy！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AdGuardHome神器&quot;&gt;&lt;a href=&quot;#AdGuardHome神器&quot; class=&quot;headerlink&quot; title=&quot;AdGuardHome神器&quot;&gt;&lt;/a&gt;AdGuardHome神器&lt;/h1&gt;&lt;p&gt;&lt;img src= &quot;/img/loading.gi
      
    
    </summary>
    
    
    
      <category term="openwrt" scheme="https://blog.dgut.top/tags/openwrt/"/>
    
      <category term="AD" scheme="https://blog.dgut.top/tags/AD/"/>
    
      <category term="luci" scheme="https://blog.dgut.top/tags/luci/"/>
    
  </entry>
  
  <entry>
    <title>三维地图</title>
    <link href="https://blog.dgut.top/2021/04/14/3d-map/"/>
    <id>https://blog.dgut.top/2021/04/14/3d-map/</id>
    <published>2021-04-14T02:57:25.000Z</published>
    <updated>2021-04-23T00:30:48.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三维地图建模调研报告"><a href="#三维地图建模调研报告" class="headerlink" title="三维地图建模调研报告"></a>三维地图建模调研报告</h1><blockquote><p>三维电子地图，或3D电子地图，就是以<a href="https://baike.baidu.com/item/三维" target="_blank" rel="noopener">三维</a>电子地图数据库为基础，按照一定<a href="https://baike.baidu.com/item/比例/5804241" target="_blank" rel="noopener">比例</a>对<a href="https://baike.baidu.com/item/现实世界/688877" target="_blank" rel="noopener">现实世界</a>或其中一部分的一个或多个方面的三维、<a href="https://baike.baidu.com/item/抽象/9021828" target="_blank" rel="noopener">抽象</a>的描述。<a href="https://baike.baidu.com/item/网络三维/11066401" target="_blank" rel="noopener">网络三维</a>电子地图不仅通过直观的地理实景模拟表现方式，为用户提供地图查询、出行导航等地图检索功能，同时集成生活资讯、<a href="https://baike.baidu.com/item/电子政务/1268" target="_blank" rel="noopener">电子政务</a>、电子商务、虚拟社区、出行导航等一系列服务。网络三维电子地图在给人们带来方便的同时，也给国家安全、社会稳定和人们隐私等带来威胁。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210414110643.jpg" alt="preview"></p><h1 id="0x00三维地图的作用"><a href="#0x00三维地图的作用" class="headerlink" title="0x00三维地图的作用"></a>0x00三维地图的作用</h1><p>三维地图作为一种记录环境信息的载体，还能作为地图查询、车辆导航等地图检索功能，具有实时、直观、可视化的优点。目前拿我们的项目来说，园区智能物流车、管道无人机巡检系统、园区巡检无人车都能利用上三维地图的这些优点。在东阳光乳源电化厂单总的交谈中得出了利用各种各样的无人车、无人机、智能设备完成电化厂的日常巡检、安防、排障、运输等功能的结论，除此之外单总还描绘了一个完全远程操控、实时操控、无人监管的宏伟蓝图。当然后者应该是一个长期的目标，我们要解决的是怎么完成前者的任务：利用大疆RTK行业无人机构建的三维地图</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210415133829.gif;charset=UTF-8" alt="智慧社区"></p><h1 id="0x01技术原理"><a href="#0x01技术原理" class="headerlink" title="0x01技术原理"></a>0x01技术原理</h1><p>地图是根据一定的数学法则，将自然地理的自然现象和<a href="https://baike.baidu.com/item/社会现象" target="_blank" rel="noopener">社会现象</a>通过概括和取舍用符号缩绘在平面上的图形。<a href="https://baike.baidu.com/item/电子地图" target="_blank" rel="noopener">电子地图</a>则是以<a href="https://baike.baidu.com/item/地图数据库" target="_blank" rel="noopener">地图数据库</a>为基础，在适当尺寸的屏幕上按照一定比例显示的地图。而三维电子地图就是以三维电子地图数据库为基础，按照一定比例对现实世界或其中一部分的一个或多个方面的<a href="https://baike.baidu.com/item/三维" target="_blank" rel="noopener">三维</a>、抽象的描述(或综合)，其形象性、功能性远强于二维电子地图。结合发展迅速的<a href="https://baike.baidu.com/item/网络通信技术" target="_blank" rel="noopener">网络通信技术</a>和丰富的计算机网络资源，三维电子地图和<a href="https://baike.baidu.com/item/通信网络技术" target="_blank" rel="noopener">通信网络技术</a>相结合，就形成了简单易用的<a href="https://baike.baidu.com/item/网络三维" target="_blank" rel="noopener">网络三维</a>电子地图。网络三维电子地图通常运用网络拓扑技术、<a href="https://baike.baidu.com/item/数据库管理系统" target="_blank" rel="noopener">数据库管理系统</a>对物体实体的坐标进行数学建模，并且基于<a href="https://baike.baidu.com/item/GIS系统" target="_blank" rel="noopener">GIS系统</a>处理、WEB技术、<a href="https://baike.baidu.com/item/计算机图形学" target="_blank" rel="noopener">计算机图形学</a>、三维仿真技术和<a href="https://baike.baidu.com/item/虚拟现实技术" target="_blank" rel="noopener">虚拟现实技术</a>所实现。</p><p>必备以下五大模块知识：</p><ol><li>如何配置航测设备，如何判断设备优劣？</li><li>如何操作设备？</li><li>如何执行一项完整的航飞项目?</li><li>如何处理飞行数据，进行倾斜建模?</li><li>如何对模型进行精细化修饰？</li></ol><p>还需要学会以下六大软件操作：</p><ol><li>DJi + Altizure</li><li>Pix4D Mapper + Inpho</li><li>Context Capture + PhotoScan</li><li>Mirauge 3D</li><li>Terrasolid</li><li>ZR-modeler</li></ol><h1 id="三维实景地图模型"><a href="#三维实景地图模型" class="headerlink" title="三维实景地图模型"></a>三维实景地图模型</h1><blockquote><p>三维实景其实我们每天都在接触，那就是我们所见所得。三维实景英文称为3D IVR，它是一种运用数码相机对现有场景进行多角度环视拍摄然后进行后期缝合并加载播放程序来完成的一种三维虚拟展示技术。三维实景在浏览中可以由观赏者对图像进行放大、缩小、移动、多角度观看等操作。经过深入的编程，可实现场景中的热点链接、多场景之间虚拟漫游、雷达方位导航等功能。三维实景技术广泛应用于诸多领域网络虚拟展示。</p></blockquote><h3 id="三维实景技术有哪些特点？"><a href="#三维实景技术有哪些特点？" class="headerlink" title="三维实景技术有哪些特点？"></a>三维实景技术有哪些特点？</h3><ol><li>通过专业相机把现场场景完整、细致地拍摄记录下来，不留死角。再通过播放器将图片一切景致，多角度、全方位展示给访问者，一览无遗。</li><li>三维实景图像源自对真实场景的摄影捕捉，虽然通过实景制作出虚拟空间，但此虚拟空间完全源自于真实的场景，有别于电脑绘制出的虚拟空间，给访问者更加真实的视觉享受。</li><li>360度环视播放效果，让访问者置身于三维立体空间里，任意穿行、观赏，身临其境，享受虚拟世界带来的奇妙幻境。</li></ol><h3 id="空间三维实景（全景展示）优势："><a href="#空间三维实景（全景展示）优势：" class="headerlink" title="空间三维实景（全景展示）优势："></a>空间三维实景（全景展示）优势：</h3><ol><li>播放终端没有特别要求，一般大众化电脑均能播放。</li><li>无需下载播放插件，省去访问者下载的麻烦，播放浏览无障碍。</li><li>网络推广没有特殊技术要求，方便加载推广。</li></ol><h3 id="应用方面："><a href="#应用方面：" class="headerlink" title="应用方面："></a>应用方面：</h3><ol><li><p>通过官方网站参观企业的厂区、厂房、大型设备、全方位展示企业基础实力，在浏览中提升企业形象</p></li><li><p>将三维实景App安装到Ipad、Iphone等移动设备上。 通过Ipad或Iphone等便携设备在展会或会谈时展示介绍企业重点厂房设备，使用先进的科技产品，在创新中增加企业美誉度。</p></li><li><p>将三维实景标注到Google地图，百度地图上。 在地图上搜索企业位置，直接点击进入三维实景展示，方便查找企业方位，在细节中完善企业行业品牌.</p></li><li><p>构建三维实景地图配合信息化图标进行远程巡检、内容查看、生产效率调节等</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210419162546.jpg" alt="中维空间--智慧校园可视化管理"></p></li></ol><h1 id="无人机倾斜摄影"><a href="#无人机倾斜摄影" class="headerlink" title="无人机倾斜摄影"></a>无人机倾斜摄影</h1><p>（<a href="https://blog.csdn.net/modeling3D/article/details/115229274?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_utm_term-0&spm=1001.2101.3001.4242" target="_blank" rel="noopener">csdn</a>）</p><blockquote><p>倾斜航空摄测量技术是测绘领域近年来发展迅猛 的一项高新技术，它通过多角度的拍摄得到同一地物不 同角度的倾斜影像，从而获取传统航空摄影测量不能获取的建筑物侧面纹理，目前在数字城市、智慧城市等的建设中应用广泛。在文物保护修复领域中，实景三维模型是最能真实反映文化遗产现状的表示方式，是文化遗产保护的重要数据基础。但由于文化遗产具有结构复杂等特殊性，要求获取构建的三维模型成果的分辨率、清晰度和材质颜色指标更高，增加了倾斜摄影数据获取难度。中维空间结合吴哥古迹保护项目，探索了如何使用无人机倾斜摄影测量技术实现高精细文化遗产实景三维模型的快速重构，为文物的保护、修复和研究提供基础数据的支撑。</p></blockquote><p>无人机倾斜摄影的具体应用有很多，如三维实景建模、三维城市地图、土石量算、矿区勘察、村镇地籍量算、管道铁道、山林勘察，通过三维建模之后，可以实现标绘、测量、分析、模型优化、内容演示、三维全景展示、可视化管理平台等。今天的重点是倾斜摄影在测量方面的应用和原理。</p><h3 id="1-无人机倾斜航空摄影"><a href="#1-无人机倾斜航空摄影" class="headerlink" title="1.无人机倾斜航空摄影"></a>1.<strong>无人机倾斜航空摄影</strong></h3><p>倾斜航空摄测量是国际测绘领域近年来倡导使用的一项高新技术，可同时从一个正摄、四个倾斜等 5 个不同的角度采集影像数据( 如图 1 所示) ，不但可获取正面影像信息，还可同时获取地物的多侧面影像信息，凭借其工期短、成本低和效率高等优势，在数字城市建设、应急指挥、国土安全、城市管理中得到了广泛的应用。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210419163440.jpg" alt="img"></p><p>相对于传统垂直下视航空摄影影像，倾斜航空拍摄的影像由于拍摄时的角度是倾斜的，所以影像具有变化的比例，倾斜拍摄影像对应的地面区域形状像一个梯形，在区域梯形前端拍摄的影像像素比梯形后端的像素高。如图 2 所示，T 为区域内目标点; T’为区域目标点在影像</p><p>上对应的点; O 为摄影中心; h 为飞行高度; c 为相机参数; t 为倾斜影像倾角; α 为倾斜影像倾角半角; β 为区域目标点 T 与摄影中心的连线与竖直方向的夹角; PP 为倾斜摄影相机主光轴与地面的交点; PP’为倾斜影像的像主点。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210419163514.jpg" alt="img"></p><p>因倾斜摄影存在高地物遮挡低地物的缺陷，传统大飞机航空摄影倾斜航空摄影飞行相对高度多为 300 m 以 上，影像地面分辨率为 5—20 cm，无法满足文化遗产高精度、精细化的要求。为获取优于 5 cm 地面分辨率的全方位无漏洞的文化遗产影像数据，需要降低飞行高度，增大航向和旁向重叠度，采用无人机进行低空飞行拍摄。</p><p>和传统航空摄影的大飞机相比，无人机具有方便、快 捷、成本低廉的独特优势。一般来说，无人机航摄通过无线设备来控制和操作不载人的飞行器，可通过航高的调节实现高空间大范围影像获取和低空间小区域精确航拍，还能够针对文化遗产数据获取的需求，对具体建筑物</p><p>进行 360°的立体环绕飞行，获取目标地物正射、倾斜航空影像，极大地增强了数据获取的科学性和时效性。</p><h3 id="2-文物建筑三维建模（中维空间案例）"><a href="#2-文物建筑三维建模（中维空间案例）" class="headerlink" title="2.文物建筑三维建模（中维空间案例）"></a>2.文物建筑三维建模（中维空间案例）</h3><p>针对文化遗产大场景与重要建筑物的实景三维模型需要不同精细程度的模型的难题，文中对无人机倾斜摄影设计方案进行了优化( 如图 3 所示) ，采用带状倾斜航空摄影+环状倾斜航空摄影的技术方案，得到遗址区的航摄数据，最后融合两种影像数据生成遗产区的实景三维</p><p>模型数据。从而在保证大区域实景三维模型的效果基础上，确保了重要遗址建筑物实景三维模型的精细程度，下面将以王家花园王宫为例介绍基于无人机倾斜航空摄影的文化遗产三维建模工艺流程。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210419163615.jpg" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210419153953.jpg" alt="倾斜摄影无人机"></p><p>传统航空摄影只能从垂直角度拍摄地物，倾斜摄影则通过在同一平台搭载多台传感器，同时从垂直、侧视等不同的角度采集影像，有效弥补了传统航空摄影的局限。那么，无人机倾斜摄影系统可以定义为: 以无人机为飞行平台，以倾斜摄影相机为任务设备的航空影像获取系统。</p><p>无人机倾斜摄影技术通过超低空倾斜摄影，从一个垂直和四个特定角度倾斜方向获取高清立体影像数据，并多角度采集信息，配合控制点或影像POS信息，影像上每个点都会有三维坐标，基于影像数据可对任意点线面进行量测，获取厘米级的测量精度并自动生成三维地理信息模型，快速获取地理信息，对建筑物等地物高度直接量算;影像中包含丰富的真实环境信息，可对影像信息的数据深度挖掘，具有高效率、低成本、数据精确、操作灵活、侧面信息可用等优点，极大调节测绘内、外业的协同工作，解决了天气等外因造成的传统人工作业延误。</p><h1 id="0x02软件"><a href="#0x02软件" class="headerlink" title="0x02软件"></a>0x02软件</h1><h2 id="1-smart-3D"><a href="#1-smart-3D" class="headerlink" title="1.smart 3D"></a>1.smart 3D</h2><p>大疆无人机三维建模教程 只要是无人机就可以（玩具除外）mavic mini也可以建模 ContextCaptureMaster/Smart3D软件入门<a href="https://www.bilibili.com/video/BV1e7411J7YA/?spm_id_from=333.788.recommend_more_video.0" target="_blank" rel="noopener">教程</a></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210421081528.png" alt="image-20210419153307045"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三维地图建模调研报告&quot;&gt;&lt;a href=&quot;#三维地图建模调研报告&quot; class=&quot;headerlink&quot; title=&quot;三维地图建模调研报告&quot;&gt;&lt;/a&gt;三维地图建模调研报告&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;三维电子地图，或3D电子地图，就是以&lt;a href
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2020年毕业一年总结</title>
    <link href="https://blog.dgut.top/2021/04/13/HEC2020/"/>
    <id>https://blog.dgut.top/2021/04/13/HEC2020/</id>
    <published>2021-04-13T02:28:54.000Z</published>
    <updated>2021-04-26T00:17:48.290Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="转眼就是2021年4月份了，时隔快一年了回到自己的网站了。同时也意味着我毕业也快一年了，工作也快一年了。"><a href="#转眼就是2021年4月份了，时隔快一年了回到自己的网站了。同时也意味着我毕业也快一年了，工作也快一年了。" class="headerlink" title="转眼就是2021年4月份了，时隔快一年了回到自己的网站了。同时也意味着我毕业也快一年了，工作也快一年了。"></a>转眼就是2021年4月份了，时隔快一年了回到自己的网站了。同时也意味着我毕业也快一年了，工作也快一年了。</h3></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210413105841.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210415111245.jpg" alt=""></p><h1 id="0x00-实习"><a href="#0x00-实习" class="headerlink" title="0x00 实习"></a>0x00 实习</h1><p>在毕业之前我去了中国光电集团实习了一段时间，承接的是海外（马来西亚）的光伏发电项目，在马来待了一段时间也算耳濡目染了一下当地人的生活习性，在那边我惊喜的发现可以当地人一个专车司机居然具有种6语言：英语、普通话、粤语、马来西亚语、泰语、潮汕话等等。这样一来就开森了，我一下就有3种语言交流了（普通话、粤语、和我一般般的英语），结果后来发现不是每个人懂那么多种语言的，还是要用英语交流。。。</p><h1 id="0x01-毕业"><a href="#0x01-毕业" class="headerlink" title="0x01 毕业"></a>0x01 毕业</h1><p>我是2020年6月份毕业的，感觉2020年过年后像是失忆了，时间很快就过了，因为疫情的缘故我们仓促毕业。在那段时间在家毕业设计，和兄弟朋友一起网上视频聊天。</p><p>终于等到了5月底回学校的通知，而这一次，不是开学，而是回去收拾东西走人。而且还分多批陆陆续续地回校，er好多同学连最后一面都见不到了。</p><p>5月底，稀稀疏疏地回到学校，在食堂吃一顿、在宿舍串串门分享一下对未来的彷徨、找老师聊聊天、拿几套衣服拍个单人毕业照。转眼宿舍已经空空的了，我送走宿舍的“大力哥”后就仅剩我一人了，心情空落落的。</p><p>在和老师一一道别合影之后我来到了辅导员的房间开始办理毕业的手续，手续很快但我却希望他能慢点。很快我们都要离开了，没想到毕业竟然是如此的简单…甚至有点儿平静，和大伙告别后离开学校。</p><p>出校门后，四年的大学生活宣告结束，突然有很多的不舍，可是已经回不去了呀~</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210415143316.png" alt="image-20210415143313608"></p><p>（拍毕业照）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210415142823.png" alt="实验室"></p><p>（私人办公室也被我们搬空了）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210415143228.png" alt="光电实验室"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210415143242.png" alt="image-20210415143239875"></p><p>（光电创新实验室）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20210415143336.png" alt="image-20210415143333363"></p><p>（宿舍门口）</p><p>再见！</p><h1 id="0x02-东阳光工作"><a href="#0x02-东阳光工作" class="headerlink" title="0x02 东阳光工作"></a>0x02 东阳光工作</h1><p>入职快一年了，我是6月底来到东阳光的研究院的，现在应该是第一次全面地接触社会，虽然在学校内已经有很多对毕业后的幻想，但是突如其来的疫情让很多计划都落空了。</p><p>唯一感到舒适的事情是毕业-面试-入职东阳光这个过程一帆风顺，在此之前一直没听说过东阳光集团，在一些当地的企业家、股长推荐之后才逐渐了解到位于长安上沙的东阳光的，话说在长安生活那么久都没有来过上沙社区的我也对这个地方感觉到很新奇，对未来一切都很期待。</p><h2 id="1-情况介绍"><a href="#1-情况介绍" class="headerlink" title="1.情况介绍"></a>1.情况介绍</h2><p>转眼就是成为东阳光的一份</p><p>我迫不及待地我很快就来到了公司这里，第一次先过来这边左看看又看看，很好奇的是这里的建筑物都很有特色，像~罗马建筑，大门看进去发现园区左右都是对称的👍。对比起上沙周围破破烂烂工业区的建筑物来说还是很气派的！</p><h3 id="1-1吃的"><a href="#1-1吃的" class="headerlink" title="1.1吃的"></a>1.1吃的</h3><p>看完环境就看了下吃的，这里有大食堂、小食堂、中餐厅、韩国料理，几乎很容易在这里找到合适的吃的东西。平时一般中午在大食堂，晚餐在小食堂、韩国料理里解决了。公司的大食堂就是我们所说的饭堂，因为很大一部分食材是公司乳源基地生产的，相当于自产自销，所以费用很低。小食堂、中餐厅、韩国料理相当于点餐的地方，接待客人或者宴请的情况来的比较多。</p><p>平时接触的一些诸如大疆、华为、中国移动、海康威视的企业代表会后也是带他们来这边就餐，算是对他们跋山涉水远道而来的一种感恩吧！</p><h3 id="1-2玩的"><a href="#1-2玩的" class="headerlink" title="1.2玩的"></a>1.2玩的</h3><p>一入职我们研究院就挑选了一些新人都参加了企业举办的年会舞蹈活动（后面有变数），我们于是乎在这个过程中认识了很多东阳光的小伙伴，后面也成为了很好的朋友。</p><h3 id="1-3住的"><a href="#1-3住的" class="headerlink" title="1.3住的"></a>1.3住的</h3><h2 id="2-入职之后的工作"><a href="#2-入职之后的工作" class="headerlink" title="2.入职之后的工作"></a>2.入职之后的工作</h2><p>入职之后就是一个崭新的员工，啥活都不懂，只能多多找这边的各种师兄师姐（我们是这样称呼的）学习，在此过程中大家都很热情，我也逐渐地看到了各位大佬的实力（佩服佩服是😎）</p><p>(未完待写)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;转眼就是2021年4月份了，时隔快一年了回到自己的网站了。同时也意味着我毕业也快一年了，工作也快一年了。&quot;&gt;&lt;a href=&quot;#转眼就是2021年4月份了，时隔快一年了回到自己的网站了。同时也意味着我毕业也快一年了，工作也快一年了。&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker学习</title>
    <link href="https://blog.dgut.top/2020/08/25/docker/"/>
    <id>https://blog.dgut.top/2020/08/25/docker/</id>
    <published>2020-08-25T01:41:09.000Z</published>
    <updated>2020-08-31T06:30:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker学习记录"><a href="#Docker学习记录" class="headerlink" title="Docker学习记录"></a>Docker学习记录</h1><p>最近也是把基于aurco的视觉室内定位做好了，摄像头通过检测aruco码就可以获得相对距离和角度，再带入整个机器人的地图中就可以起到一个很好的辅助定位的功能。不过确定就是aruco标签的样式是无法更改的，就一张A4纸贴在墙面上非常影响美观，所以说下一步应该就是进行<code>物体检测</code>例如检测到一幅画、一面墙壁、一个楼梯等特征比较明显的物体来辅助定位。</p><p>要实现<code>物体检测</code>我觉得光靠opencv的级联分类器是远远不够的，所以项目肯定是要往速度学习上靠拢的。项目组正好有一台正在使用的GPU服务器，我粗略地看了下配置：cpu是两路志强<code>E5-2640 v4 @ 2.40GHz</code>，8路<code>gtx1080ti</code>，250G内存。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200825101817.png" alt=""></p><p>目前有个问题就是，服务器目前运行着项目组其他成员的一些训练程序而且我们用的编程环境可能不同就会造成<code>cuda</code>、<code>tensorflow</code>环境错误。因此我们要使用<code>docker</code>作为训练环境的整体。本文就是记录一些<code>docker</code>的使用方法，作为初学者，记录一下还是很有必要的。</p><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://baike.baidu.com/item/docker/13344470" target="_blank" rel="noopener">简介</a>：Docker是一个<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a>的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>或<a href="https://baike.baidu.com/item/Windows/165458" target="_blank" rel="noopener">Windows</a> 机器上，也可以实现<a href="https://baike.baidu.com/item/虚拟化/547949" target="_blank" rel="noopener">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/沙箱/393318" target="_blank" rel="noopener">沙箱</a>机制，相互之间不会有任何接口。</p><p> Docker <a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">安装</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><p>下载地址：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fhub.docker.com%2Feditions%2Fcommunity%2Fdocker-ce-desktop-windows" target="_blank" rel="noopener">Docker Desktop for Windows - Docker Hub</a></p><p>选择 stable 稳定版下载，傻瓜式安装过程，一键到底。</p><p>电脑重启后打开 Docker，点击右下角任务栏 Docker 的 Dashboard。</p><p>在终端输入docker后看到如下信息则证明安装成功：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200825102534.png" alt=""></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>最近在公司3楼布置了一圈AP网络，用于巡检机器人的调试，但是我们对这个网络的容量一直不是很清楚，今天在github上看到了<code>librespeed-speedtest</code>这个<a href="https://github.com/librespeed/speedtest" target="_blank" rel="noopener">项目</a>，并且这个项目支持docker部署，所以就拿来实践一下，顺带测试一下wifi局域网吞吐容量。<a href="https://hub.docker.com/r/adolfintel/speedtest" target="_blank" rel="noopener">docker地址</a></p><ul><li>机器人网络示意图</li></ul><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200825135102.png" alt=""></p><ul><li>speedtest docker项目</li></ul><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200825102722.png" alt=""></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p><a href="https://www.jianshu.com/p/00e8ae89224d" target="_blank" rel="noopener">简书</a></p><p>docker部署起来也是超简单，2分钟就好了</p><h3 id="1-镜像下载："><a href="#1-镜像下载：" class="headerlink" title="1.镜像下载："></a>1.镜像下载：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull adolfintel/speedtest</span><br></pre></td></tr></table></figure><p>网络不好建议重复操作，若显示类似于下方文字，则说明下载完成：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200825135411.png" alt=""></p><h3 id="2-启动docker"><a href="#2-启动docker" class="headerlink" title="2.启动docker"></a>2.启动docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8080:80 adolfintel/speedtest:latest</span><br></pre></td></tr></table></figure><blockquote><ul><li>-d，后台运行（建议使用）</li><li>-p，端口映射（可自行修改其它端口）</li></ul></blockquote><p>此时，可以在之前的 Dashboard 中看到后台运行的容器。本机能打开网页 <a href="https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8080" target="_blank" rel="noopener">http://localhost:8080</a> 也能说明服务启动成功。</p><h3 id="3-测速"><a href="#3-测速" class="headerlink" title="3.测速"></a>3.测速</h3><p>测速过程就非常傻瓜了~</p><p>局域网的其它设备打开网页 http://[PC IP]:8080 即可进行测速。如果不能访问，可能是防火墙、路由器设置或其它方面的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.2.182:8080&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200825135726.png" alt=""></p><h3 id="4-设置DMZ主机"><a href="#4-设置DMZ主机" class="headerlink" title="4.设置DMZ主机"></a>4.设置DMZ主机</h3><blockquote><p>让您得以将一部计算机公开显露在互联网上，使所有上传的封包全数转向您指定的计算机。这对您在运行一些使用非特定内传通信端口（incoming port）的应用程序时会相当有用。请谨慎使用。</p></blockquote><p>通俗来说就是电脑通过路由器链接到公司局域网，路由器的ip和电脑局域网ip不同（百层nat狗头），要把电脑设置为<code>DMZ主机</code>之后访问路由器ip就可以访问到测速网页了。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200825140243.png" alt=""></p><h2 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">登录服务器http://192.168.221.11/</span><br><span class="line">ssh zwj@AISRV</span><br><span class="line">查看docker运行列表</span><br><span class="line">docker ps</span><br><span class="line">运行docker</span><br><span class="line">docker run -d -p 8081:80 adolfintel/speedtest:latest</span><br><span class="line">停止docker</span><br><span class="line">docker stop compassionate_knuth</span><br><span class="line">进入docker 启动docker</span><br><span class="line">cd work</span><br><span class="line">cd comprehen/</span><br><span class="line">./docker_start.sh </span><br><span class="line">./docker_into.sh</span><br></pre></td></tr></table></figure><h1 id="dockerd搭建宝塔管理面板"><a href="#dockerd搭建宝塔管理面板" class="headerlink" title="dockerd搭建宝塔管理面板"></a>dockerd搭建宝塔管理面板</h1><blockquote><p>宝塔Linux面板是提升运维效率的服务器管理软件，支持一键LAMP/LNMP/集群/监控/网站/FTP/数据库/JAVA等100多项服务器管理功能。<br>有30个人的专业团队研发及维护，经过200多个版本的迭代，功能全，少出错且足够安全，已获得全球百万用户认可安装。运维要高效，装宝塔。</p></blockquote><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>先从<code>docker</code> 拉取一个<code>centos</code>镜像下来先</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure><p>运行镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t -d --name baota-zwj -p 20:20 -p 21:21 -p 80:80 -p 443:443 -p 888:888 -p 8888:8888 -p 8084:8084 -p 8085:8085 --privileged=true -v /data1/zwj/baota:/www centos</span><br></pre></td></tr></table></figure><blockquote><p>-p 外部端口号：内部端口号，这里开放了20、21、80、443、888、8888、8084、8085端口</p></blockquote><blockquote><p>-v 本地路径：内部路径 想对于挂载一个硬盘到docker上去，这个硬盘可以在本地中映射到docker里</p></blockquote><p>进入宝塔docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it baota-zwj /bin/bash</span><br></pre></td></tr></table></figure><p>宝塔安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure><p>安装成功后会显示宝塔的登录地址和账户密码一般是：<a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a> </p><p>启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/bt start</span><br></pre></td></tr></table></figure><p>登录</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200831142929.png" alt=""></p><p>进入面板</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200831142905.png" alt=""></p><p>资源监控</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200831143027.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker学习记录&quot;&gt;&lt;a href=&quot;#Docker学习记录&quot; class=&quot;headerlink&quot; title=&quot;Docker学习记录&quot;&gt;&lt;/a&gt;Docker学习记录&lt;/h1&gt;&lt;p&gt;最近也是把基于aurco的视觉室内定位做好了，摄像头通过检测aruco码就可
      
    
    </summary>
    
    
    
      <category term="ubuntu" scheme="https://blog.dgut.top/tags/ubuntu/"/>
    
      <category term="docker" scheme="https://blog.dgut.top/tags/docker/"/>
    
      <category term="speedtest" scheme="https://blog.dgut.top/tags/speedtest/"/>
    
  </entry>
  
  <entry>
    <title>基于ArUco的距离角度定位</title>
    <link href="https://blog.dgut.top/2020/08/19/aruco-2d/"/>
    <id>https://blog.dgut.top/2020/08/19/aruco-2d/</id>
    <published>2020-08-19T00:48:45.000Z</published>
    <updated>2020-08-19T01:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于ArUco的距离角度定位"><a href="#基于ArUco的距离角度定位" class="headerlink" title="基于ArUco的距离角度定位"></a>基于ArUco的距离角度定位</h1><blockquote><p>利用aruco.estimatePoseSingleMarkers(）函数返回找到的aurco标签的rvec旋转矩阵、tvec位移矩阵进行换算，找出aurco相对于相机cam的距离和角度，实现利用aurco进行定位</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> cv2.aruco <span class="keyword">as</span> aruco</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="comment">#加载鱼眼镜头的yaml标定文件，检测aruco并且估算与标签之间的距离,获取偏航，俯仰，滚动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载相机纠正参数</span></span><br><span class="line">cv_file = cv2.FileStorage(<span class="string">"yuyan.yaml"</span>, cv2.FILE_STORAGE_READ)</span><br><span class="line">camera_matrix = cv_file.getNode(<span class="string">"camera_matrix"</span>).mat()</span><br><span class="line">dist_matrix = cv_file.getNode(<span class="string">"dist_coeff"</span>).mat()</span><br><span class="line">cv_file.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认cam参数</span></span><br><span class="line"><span class="comment"># dist=np.array(([[-0.58650416 , 0.59103816, -0.00443272 , 0.00357844 ,-0.27203275]]))</span></span><br><span class="line"><span class="comment"># newcameramtx=np.array([[189.076828   ,  0.    ,     361.20126638]</span></span><br><span class="line"><span class="comment">#  ,[  0 ,2.01627296e+04 ,4.52759577e+02]</span></span><br><span class="line"><span class="comment">#  ,[0, 0, 1]])</span></span><br><span class="line"><span class="comment"># mtx=np.array([[398.12724231  , 0.      ,   304.35638757],</span></span><br><span class="line"><span class="comment">#  [  0.       ,  345.38259888, 282.49861858],</span></span><br><span class="line"><span class="comment">#  [  0.,           0.,           1.        ]])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc('M', 'J', 'P', 'G'))</span></span><br><span class="line"><span class="comment"># cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)</span></span><br><span class="line"><span class="comment"># cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)</span></span><br><span class="line"></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX <span class="comment">#font for displaying text (below)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#num = 0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    h1, w1 = frame.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 读取摄像头画面</span></span><br><span class="line">    <span class="comment"># 纠正畸变</span></span><br><span class="line">    newcameramtx, roi = cv2.getOptimalNewCameraMatrix(camera_matrix, dist_matrix, (h1, w1), <span class="number">0</span>, (h1, w1))</span><br><span class="line">    dst1 = cv2.undistort(frame, camera_matrix, dist_matrix, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">    x, y, w1, h1 = roi</span><br><span class="line">    dst1 = dst1[y:y + h1, x:x + w1]</span><br><span class="line">    frame=dst1</span><br><span class="line"></span><br><span class="line">    <span class="comment">#灰度化，检测aruco标签，所用字典为6×6——250</span></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)</span><br><span class="line">    parameters =  aruco.DetectorParameters_create()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用aruco.detectMarkers()函数可以检测到marker，返回ID和标志板的4个角点坐标</span></span><br><span class="line">    corners, ids, rejectedImgPoints = aruco.detectMarkers(gray,aruco_dict,parameters=parameters)</span><br><span class="line"></span><br><span class="line"><span class="comment">#    如果找不打id</span></span><br><span class="line">    <span class="keyword">if</span> ids <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment">#获取aruco返回的rvec旋转矩阵、tvec位移矩阵</span></span><br><span class="line">        rvec, tvec, _ = aruco.estimatePoseSingleMarkers(corners, <span class="number">0.05</span>, camera_matrix, dist_matrix)</span><br><span class="line">        <span class="comment"># 估计每个标记的姿态并返回值rvet和tvec ---不同</span></span><br><span class="line">        <span class="comment">#rvec为旋转矩阵，tvec为位移矩阵</span></span><br><span class="line">        <span class="comment"># from camera coeficcients</span></span><br><span class="line">        (rvec-tvec).any() <span class="comment"># get rid of that nasty numpy value array error</span></span><br><span class="line">        <span class="comment">#print(rvec)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">#在画面上 标注auruco标签的各轴</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rvec.shape[<span class="number">0</span>]):</span><br><span class="line">            aruco.drawAxis(frame, camera_matrix, dist_matrix, rvec[i, :, :], tvec[i, :, :], <span class="number">0.03</span>)</span><br><span class="line">            aruco.drawDetectedMarkers(frame, corners,ids)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">###### 显示id标记 #####</span></span><br><span class="line">        cv2.putText(frame, <span class="string">"Id: "</span> + str(ids), (<span class="number">0</span>,<span class="number">64</span>), font, <span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>,cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">###### 角度估计 #####</span></span><br><span class="line">        <span class="comment">#print(rvec)</span></span><br><span class="line">        <span class="comment">#考虑Z轴（蓝色）的角度</span></span><br><span class="line">        <span class="comment">#本来正确的计算方式如下，但是由于蜜汁相机标定的问题，实测偏航角度能最大达到104°所以现在×90/104这个系数作为最终角度</span></span><br><span class="line">        deg=rvec[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>]/math.pi*<span class="number">180</span></span><br><span class="line">        <span class="comment">#deg=rvec[0][0][2]/math.pi*180*90/104</span></span><br><span class="line">        <span class="comment"># 旋转矩阵到欧拉角</span></span><br><span class="line">        R=np.zeros((<span class="number">3</span>,<span class="number">3</span>),dtype=np.float64)</span><br><span class="line">        cv2.Rodrigues(rvec,R)</span><br><span class="line">        sy=math.sqrt(R[<span class="number">0</span>,<span class="number">0</span>] * R[<span class="number">0</span>,<span class="number">0</span>] +  R[<span class="number">1</span>,<span class="number">0</span>] * R[<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line">        singular=sy&lt; <span class="number">1e-6</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> singular:<span class="comment">#偏航，俯仰，滚动</span></span><br><span class="line">            x = math.atan2(R[<span class="number">2</span>, <span class="number">1</span>], R[<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">            y = math.atan2(-R[<span class="number">2</span>, <span class="number">0</span>], sy)</span><br><span class="line">            z = math.atan2(R[<span class="number">1</span>, <span class="number">0</span>], R[<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x = math.atan2(-R[<span class="number">1</span>, <span class="number">2</span>], R[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">            y = math.atan2(-R[<span class="number">2</span>, <span class="number">0</span>], sy)</span><br><span class="line">            z = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 偏航，俯仰，滚动换成角度</span></span><br><span class="line">        rx = x * <span class="number">180.0</span> / <span class="number">3.141592653589793</span></span><br><span class="line">        ry = y * <span class="number">180.0</span> / <span class="number">3.141592653589793</span></span><br><span class="line">        rz = z * <span class="number">180.0</span> / <span class="number">3.141592653589793</span></span><br><span class="line"></span><br><span class="line">        cv2.putText(frame,<span class="string">'deg_z:'</span>+str(ry)+str(<span class="string">'deg'</span>),(<span class="number">0</span>, <span class="number">140</span>), font, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>,</span><br><span class="line">                    cv2.LINE_AA)</span><br><span class="line">        <span class="comment">#print("偏航，俯仰，滚动",rx,ry,rz)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">###### 距离估计 #####</span></span><br><span class="line">        distance = ((tvec[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] + <span class="number">0.02</span>) * <span class="number">0.0254</span>) * <span class="number">100</span>  <span class="comment"># 单位是米</span></span><br><span class="line">        <span class="comment">#distance = (tvec[0][0][2]) * 100  # 单位是米</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 显示距离</span></span><br><span class="line">        cv2.putText(frame, <span class="string">'distance:'</span> + str(round(distance, <span class="number">4</span>)) + str(<span class="string">'m'</span>), (<span class="number">0</span>, <span class="number">110</span>), font, <span class="number">1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>,</span><br><span class="line">                    cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line">        <span class="comment">####真实坐标换算####（to do）</span></span><br><span class="line">        <span class="comment"># print('rvec:',rvec,'tvec:',tvec)</span></span><br><span class="line">        <span class="comment"># # new_tvec=np.array([[-0.01361995],[-0.01003278],[0.62165339]])</span></span><br><span class="line">        <span class="comment"># # 将相机坐标转换为真实坐标</span></span><br><span class="line">        <span class="comment"># r_matrix, d = cv2.Rodrigues(rvec)</span></span><br><span class="line">        <span class="comment"># r_matrix = -np.linalg.inv(r_matrix)  # 相机旋转矩阵</span></span><br><span class="line">        <span class="comment"># c_matrix = np.dot(r_matrix, tvec)  # 相机位置矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">##### DRAW "NO IDS" #####</span></span><br><span class="line">        cv2.putText(frame, <span class="string">"No Ids"</span>, (<span class="number">0</span>,<span class="number">64</span>), font, <span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>,cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示结果画面</span></span><br><span class="line">    cv2.imshow(<span class="string">"frame"</span>,frame)</span><br><span class="line"></span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key == <span class="number">27</span>:         <span class="comment"># 按esc键退出</span></span><br><span class="line">        print(<span class="string">'esc break...'</span>)</span><br><span class="line">        cap.release()</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key == ord(<span class="string">' '</span>):   <span class="comment"># 按空格键保存</span></span><br><span class="line"><span class="comment">#        num = num + 1</span></span><br><span class="line"><span class="comment">#        filename = "frames_%s.jpg" % num  # 保存一张图像</span></span><br><span class="line">        filename = str(time.time())[:<span class="number">10</span>] + <span class="string">".jpg"</span></span><br><span class="line">        cv2.imwrite(filename, frame)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200819094339.png" alt=""><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200819094340.png" alt=""></p><p>项目地址：<a href="https://github.com/ZengWenJian123/aruco_positioning_2D" target="_blank" rel="noopener">https://github.com/ZengWenJian123/aruco_positioning_2D</a></p><p>博客地址：<a href="https://blog.dgut.top/2020/08/19/aruco-2d/">https://blog.dgut.top/2020/08/19/aruco-2d/</a></p><p>csdn：<a href="https://blog.csdn.net/dgut_guangdian/article/details/108093643" target="_blank" rel="noopener">https://blog.csdn.net/dgut_guangdian/article/details/108093643</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于ArUco的距离角度定位&quot;&gt;&lt;a href=&quot;#基于ArUco的距离角度定位&quot; class=&quot;headerlink&quot; title=&quot;基于ArUco的距离角度定位&quot;&gt;&lt;/a&gt;基于ArUco的距离角度定位&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;利用aruco.e
      
    
    </summary>
    
    
    
      <category term="opencv" scheme="https://blog.dgut.top/tags/opencv/"/>
    
      <category term="aruco" scheme="https://blog.dgut.top/tags/aruco/"/>
    
      <category term="python" scheme="https://blog.dgut.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>学习matplotlib-python数据可视化</title>
    <link href="https://blog.dgut.top/2020/08/17/learn-matplotlib/"/>
    <id>https://blog.dgut.top/2020/08/17/learn-matplotlib/</id>
    <published>2020-08-17T02:58:06.000Z</published>
    <updated>2020-08-17T06:44:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>matplotlib</code>是<a href="https://zh.wikipedia.org/wiki/Python" target="_blank" rel="noopener">Python</a>编程语言及其数值数学扩展包 <a href="https://zh.wikipedia.org/wiki/NumPy" target="_blank" rel="noopener">NumPy</a>的可视化操作界面。它利用通用的<a href="https://zh.wikipedia.org/wiki/部件工具箱" target="_blank" rel="noopener">图形用户界面工具包</a>，如Tkinter, wxPython, <a href="https://zh.wikipedia.org/wiki/Qt" target="_blank" rel="noopener">Qt</a>或<a href="https://zh.wikipedia.org/wiki/GTK%2B" target="_blank" rel="noopener">GTK+</a>，向应用程序嵌入式绘图提供了<a href="https://zh.wikipedia.org/wiki/应用程序接口" target="_blank" rel="noopener">应用程序接口</a>（API）。此外，matplotlib还有一个基于图像处理库（如开放图形库OpenGL）的pylab接口，其设计与<a href="https://zh.wikipedia.org/wiki/MATLAB" target="_blank" rel="noopener">MATLAB</a>非常类似–尽管并不怎么好用<a href="https://zh.wikipedia.org/wiki/Wikipedia:列明来源" target="_blank" rel="noopener">[来源请求]</a>。SciPy就是用matplotlib进行图形绘制。</p><p>matplotlib最初由John D. Hunter撰写，它拥有一个活跃的开发社区，并且根据BSD样式许可证分发。 在John D. Hunter2012年去世前不久，Michael Droettboom被提名为matplotlib的主要开发者。</p><p>截至到2015年10月30日，matplotlib 1.5.x支持Python 2.7到3.5版本。Matplotlib 1.2是第一个支持Python 3.x的版本。Matplotlib 1.4是支持Python 2.6的最后一个版本。</p><blockquote><p>Matplotlib 可能是 Python 2D-绘图领域使用最广泛的套件。它能让使用者很轻松地将数据图形化，并且提供多样化的输出格式。这里将会探索 matplotlib 的常见用法。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Matplotlib及其依赖项可作为轮包用于macOS，Windows和Linux发行版：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install -U pip</span><br><span class="line">python -m pip install -U matplotlib</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200817110828.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Matplotlib&quot;&gt;&lt;a href=&quot;#Matplotlib&quot; class=&quot;headerlink&quot; title=&quot;Matplotlib&quot;&gt;&lt;/a&gt;Matplotlib&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
      <category term="python" scheme="https://blog.dgut.top/tags/python/"/>
    
      <category term="matplotlib" scheme="https://blog.dgut.top/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>室内定位</title>
    <link href="https://blog.dgut.top/2020/08/03/%E8%A7%86%E8%A7%89%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D/"/>
    <id>https://blog.dgut.top/2020/08/03/%E8%A7%86%E8%A7%89%E5%AE%A4%E5%86%85%E5%AE%9A%E4%BD%8D/</id>
    <published>2020-08-03T01:35:57.000Z</published>
    <updated>2021-04-27T06:36:56.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="室内定位"><a href="#室内定位" class="headerlink" title="室内定位"></a>室内定位</h1><p>机器人的室内定位由于卫星导航失效，主要利用机器人底盘 的<code>轮式光电编码器里程记</code>、<code>惯性测量模块</code>和<code>视觉传感器</code>进行定位。轮式里程计和惯性导航集成在机器人的底盘硬件部分，二者算法简单快速，但精度不高，容易受到环境的影响且存在严重的<code>误差累积</code>。同时机器人使用的是<a href="https://baike.baidu.com/item/%E9%BA%A6%E5%85%8B%E7%BA%B3%E5%A7%86%E8%BD%AE/3827219?fr=aladdin" target="_blank" rel="noopener">麦克纳姆轮</a>它们允许<strong>横盘走势</strong>、全方向移动但是可以被横向推着走，轮子上的横向<strong>小轮的运动姿态无法被编码器捕获</strong>，这样会加剧里程计的误差累计。</p><p>所以我们需要利用机器人上搭载的摄像头进行视觉定位进行<code>辅助组合定位</code>。</p><h1 id="国内外的解决方法"><a href="#国内外的解决方法" class="headerlink" title="国内外的解决方法"></a>国内外的解决方法</h1><table><thead><tr><th>定位技术</th><th>范围</th><th>分辨率</th><th>抗干扰</th></tr></thead><tbody><tr><td>RFID射频标签</td><td>5cm-5m</td><td>米级</td><td>弱</td></tr><tr><td>WIFI</td><td>5-10m</td><td>米级</td><td>强</td></tr><tr><td>蓝牙</td><td>2-10m</td><td>米级</td><td>弱</td></tr><tr><td>激光雷达SLAM</td><td>0-10(25)m</td><td>厘米级</td><td>强</td></tr><tr><td>超宽频UWB标签</td><td>60-300m</td><td>分米级</td><td>强</td></tr><tr><td>红外线</td><td>5-10m</td><td>-</td><td>弱</td></tr><tr><td>超声波</td><td>1-10m</td><td>分米级</td><td>强</td></tr><tr><td>计算机视觉</td><td>1m-10m</td><td>米级</td><td>弱</td></tr></tbody></table><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200803101357.png" alt=""></p><h2 id="RFID-定位技术-1"><a href="#RFID-定位技术-1" class="headerlink" title="RFID 定位技术[1]"></a>RFID 定位技术[1]</h2><p>常用的 RFID（Radio Frequency Identification）定位系统主要由标签、读写器、中间件以及数据库四个部分组成。其定位方法也比较简单，首先通过读写器接收目标设备与标签之间的位置关系信息，之后将该信息通过中间件传入定位系统进行后续操作。在 RFID 定位的应用性研究方面，许多团队已经取得了不错的研究<br>成果。2004 年 Ni 团队完成了基于 RFID 技术的 LANDMARC 系统，在实现过程中提出了一种基于固定位置的参考标签辅助定位方法[2]，该方法使得系统的定位精度被控制在 1m 内。但是固定位置的参考标签有一定的局限性，为了改善这个问题，Zhao 项目组采用大量的参考标签作为辅助[3]，提前剔除掉待定位物品中可<br>能性不大的位置信息，降低计算量的同时也提高了定位精度。以上述研究为代表，不难发现 RFID 定位技术有着定位速度快、对环境要求低的优点，但同时也有着需要提前部署额外基站设备的劣势。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200803110427.png" alt=""></p><p>小结：定位速度快、对环境要求低的优点，但同时也有着需要提前部署额外基站设备的劣势。</p><h2 id="Wi-Fi-定位技术"><a href="#Wi-Fi-定位技术" class="headerlink" title="Wi-Fi 定位技术"></a>Wi-Fi 定位技术</h2><p>Wi-Fi 是一种基于 IEEE 802.11 标准的 WLAN 技术。Wi-Fi 定位的实现原理基于位置指纹模型，首先根据各个 AP 接收目标发出的 Wi-Fi 信号的强弱程度构建位置指纹模型，然后将定位时的 Wi-Fi 信号强度与模型中的记录进行匹配从实现定位。比较常用的视觉定位系统是由微软研究院研发的 RADAR 定位系统，该系<br>统能够达到 m 级的定位精度[4]。最近，有研究将 Wi-Fi 定位与递归神经网络（Recurrent Neural Networks，RNN）相结合，提出了一种基于 RNN 模型的 Wi-Fi定位系统。与多层感知模型（Multilayer Perceptron，MLP）相比，基于 RNN 的Wi-Fi 定位系统具有更高的定位精度[5]，但定位方法仍未脱离额外基站的辅助。Wi-Fi 定位技术之所以如此普遍在于其性价比较高，用户可以通过移动终端（如手机、笔记本等智能设备）实现定位。同时，基于 Wi-Fi 的定位模型计算比较简单，信号传输速度较快，覆盖半径较大。但要实现更高精度的定位，仍需要提前部署更多的 AP，造成较多的前期资源投入。</p><p>小结：wifi定位技术可以复用现有的机器人通讯设备，要实现更高精度的定位，仍需要提前部署更多的 AP，而且需要提前测量网格中的wifi位置指纹。</p><h2 id="蓝牙定位技术"><a href="#蓝牙定位技术" class="headerlink" title="蓝牙定位技术"></a>蓝牙定位技术</h2><p>蓝牙技术是一种基于无线数据规范，其定位原理是通过计算蓝牙基站发射信号到达目标设备的时间，然后根据时间计算距离确定目标位置。Momose 项目组基于粒子滤波和蓝牙信标的定位算法，通过修正 particle filter 的似然函数，减少了蓝牙信号在传输过程中可能受到环境因素的干扰[6]。在另一个研究中，Zhu 等<br>人提出了一种基于 RSSI（Receive Signal Strength Indication）的蓝牙定位方法[7]。该方法为了减小由于所选取参考点位置不同而带来的定位误差，设计了一个Gaussian filter 来预处理不同采样点所接收的蓝牙信号，使定位精度被控制在 1m以内的概率提升为 80%。蓝牙定位技术的安全性、稳定性、便捷性是它的突出优势，但蓝牙定位技术的局限性也同样明显，由于基站信号强度的限制其只能在较小范围中实现定位。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200803110311.png" alt=""></p><h2 id="UWB"><a href="#UWB" class="headerlink" title="UWB"></a>UWB</h2><p>UWB技术是一种使用1GHz以上频率带宽的无线载波通信技术。它不采用正弦载波，而是利用纳秒级的非正弦波窄脉冲传输数据，因此其所占的<a href="https://baike.baidu.com/item/频谱/7707276" target="_blank" rel="noopener">频谱</a>范围很大，尽管使用<a href="https://baike.baidu.com/item/无线通信/80254" target="_blank" rel="noopener">无线通信</a>，但其数据传输速率可以达到几百兆比特每秒以上。使用UWB技术可在非常宽的带宽上传输信号，美国联邦通信委员会（<a href="https://baike.baidu.com/item/FCC/2146" target="_blank" rel="noopener">FCC</a>）对UWB技术的规定为：在3.1~10.6GHz频段中占用500MHz以上的<a href="https://baike.baidu.com/item/带宽/266879" target="_blank" rel="noopener">带宽</a>。</p><p>UWB技术始于20世纪60年代兴起的脉冲通信技术。UWB技术利用频谱极宽的超宽基带脉冲进行通信，故又称为基带通信技术、无线载波通信技术，主要用于<a href="https://baike.baidu.com/item/军用雷达/3183877" target="_blank" rel="noopener">军用雷达</a>、定位和低截获率/低侦测率的通信系统中。2002年2月，美国联邦通信委员会发布了民用UWB设备使用频谱和功率的初步规定。该规定中，将相对带宽大于0.2或在传输的任何时刻带宽大于500MHz的通信系统称为UWB系统，同时批准了UWB技术可用于民用商品。随后，日本于2006年8月开放了超宽带频段。由于UWB技术具有数据传输速率高（达1Gbit/s）、抗多径干扰能力强、功耗低、成本低、穿透能力强、截获率低、与现有其他无线通信系统共享频谱等特点，UWB技术成为无线个人局域网通信技术（WPAN）的首选技术.</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200803110343.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200805135828.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200805135902.png" alt=""></p><p>小结：定位准确，但是需要部署有源基站</p><h2 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h2><p>机器人视觉研究的核心内容是：<strong>视觉定位与导航、路径规划、避障、多传感器融合</strong>。视觉定位技术有多种，包括单目视觉、双目视觉、多目视觉、RGB-D等，后三种方法可以使图像具有深度信息，这些视觉“眼睛”亦可以称为VO–视觉里程计。VO在机器人乃至计算机视觉问题中，是一个通过分析处理相关图像序列来确定机器人的位置和姿态的解决方案。</p><p>现今，随着计算机图像处理技术的不断进步以及传感器电子科学的飞速发展，使得越来越多的研究者采用摄像机作为全自主移动机器人的感知元器件，这主要是因为常见的超声或红外传感器感知信息能力有限，鲁棒性差，而视觉系统则可以弥补这些缺点。但是，现实世界是立体的、三维的，而投影在摄像头感光器件（CCD/CMOS）上的图像是二维的、平面的，因此，基于摄像机的视觉处理目标就是从感知到的二维图像中提取有关的三维世界信息，用于机器人的定位与导航。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715113031.png" alt=""></p><p>小结：可以利用机器人已有的视觉模块，但是很容易被干扰，精度也难得到很高的水平。</p><h1 id="视觉定位研究"><a href="#视觉定位研究" class="headerlink" title="视觉定位研究"></a>视觉定位研究</h1><p>视觉定位不需要诸如wifi、蓝牙、UWB等定位方式提前在定位地点部署基站，视觉定位经过多年的发展广泛应用于机器人定位、物流等领域。在线定位阶段，常用的视觉定位系统主要做了三件事情：图像信息匹配、位姿求解、位置计算，其中位姿求解对视觉定位起到关键作用。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715093858.png" alt=""></p><h2 id="ArUco标签"><a href="#ArUco标签" class="headerlink" title="ArUco标签"></a>ArUco标签</h2><p>ArUco 是由RafaelMuñoz和Sergio Garrido开发的用于检测方形基准标记的流行库，其在许多计算机视觉应用程序中，姿势估计非常重要：机器人导航，增强现实等等。该过程基于发现真实环境中的3d点与其2d图像投影之间的对应关系。这通常是一个困难的步骤，因此通常使用合成或基准标记来简化操作。<br>使用ArUco记号通常是一个常用的途径之一。这标记的主要优势是单个记号就提供了获取相机姿态的足够对应信息。同时，记号的内部二进制编码使得标记在错误检查和修正等方面保持一定的稳定性。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715091518.png" alt=""></p><p>一个ArUco标记外围都有一组黑色边框，同时内部有着确定该标记ID的二维矩阵组合而成。黑色的边框能加速标记在图像中的检测速度，内部的二维编码能唯一识别该标记，同时进行错误检测和错误修复。标记的大小确定了内部矩阵的大小，上图是一个6×6大小的标记带有36bits的信息。而这些信息储存在不标记字典中。</p><h2 id="ArUco与二维码的比较"><a href="#ArUco与二维码的比较" class="headerlink" title="ArUco与二维码的比较"></a>ArUco与二维码的比较</h2><table><thead><tr><th>功能</th><th>ArUco</th><th>二维码</th></tr></thead><tbody><tr><td>储存信息</td><td>只能存储简单id数字信息</td><td>可以存储任意自定义信息</td></tr><tr><td>检测难易</td><td>检测简单、快速，并且具有很强的鲁棒性</td><td>在远距离、大偏角容易丢失</td></tr><tr><td>检测模块</td><td>cv2.aruco模块，直接返回标签的姿势等信息</td><td>opencv4.0+才完全支持，且识别效率不高</td></tr></tbody></table><p>在目前室内定位应用中，我们无需在标签上存储太多的信息，有区分的id即可，实际验证中ArUco更容易利用摄像头捕捉到（这很重要），况且ArUco本身就是广泛应用于做姿势估计的。</p><h2 id="ArUco标签识别过程"><a href="#ArUco标签识别过程" class="headerlink" title="ArUco标签识别过程"></a>ArUco标签识别过程</h2><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200805151200.png" alt=""></p><p>1.灰度化画面信息像素：摄像头采集到的信息一般是彩色的，但是我们的二维码是黑白的<br>2.设置预定义的字典： aruco.Dictionary_get(aruco.DICT_6X6_250)<br>3.使用默认值初始化检测器参数： aruco.DetectorParameters_create()<br>4.解码：检测到marker，返回ID和标志板的4个角点坐标，</p><p>具体过程可以看我的这篇文章：<a href="https://blog.dgut.top/2020/07/15/python-aruco/">链接1</a> <a href="https://blog.csdn.net/dgut_guangdian/article/details/107814300" target="_blank" rel="noopener">链接2</a></p><h2 id="ArUco识别结果"><a href="#ArUco识别结果" class="headerlink" title="ArUco识别结果"></a>ArUco识别结果</h2><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715114612.png" alt=""></p><hr><h2 id="获取与aruco标签之间的距离"><a href="#获取与aruco标签之间的距离" class="headerlink" title="获取与aruco标签之间的距离"></a>获取与aruco标签之间的距离</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###### 距离估计 与相机标定影响很大#####</span></span><br><span class="line">distance = ((tvec[<span class="number">0</span>][<span class="number">0</span>][<span class="number">2</span>] + <span class="number">0.02</span>) * <span class="number">0.0254</span>) * <span class="number">100</span>  <span class="comment"># 单位是米</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200812144658.png" alt=""><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200812152218.jpg" alt=""></p><h2 id="To-do"><a href="#To-do" class="headerlink" title="To do"></a>To do</h2><p>获取角度</p><p>rvec是以弧度表示的欧拉角。需要先使用cv2.Rodrigues将rvec转换为矩阵。然后将矩阵转换为欧拉角，rvec是一个指向向量，向量的长度（以弧度为单位）对应于垂直于该指向向量的平面中的旋转弧度。</p><p><code>rvec</code>是Rodrigues旋转向量或<a href="https://en.wikipedia.org/wiki/Axis–angle_representation" target="_blank" rel="noopener">轴角表示</a></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200812162254.png" alt=""></p><p><code>rvec</code>和<code>tvec</code>代表什么？</p><p>现在，<code>rvec</code>和<code>tvec</code>代表什么？</p><p>它们允许将以一个坐标系表示的3D点转换为另一个坐标系。在这里，您可以将标签框架中表示的3D点转换为相机框架：</p><p><img src= "/img/loading.gif" data-src="https://answers.opencv.org/upfiles/1562748098917871.png" alt="图片说明"></p><p>因此，对于第一种情况，您应该具有（这里以标记X轴为例）：</p><p><img src= "/img/loading.gif" data-src="https://answers.opencv.org/upfiles/15627482777940383.png" alt="图片说明"></p><p>对于平凡的情况，您可以通过查看允许将标签的X轴，Y轴和Z轴转换为相机框架的值来恢复旋转矩阵。</p><hr><p>我认为，极少需要使用欧拉角，我不喜欢它们。为什么？</p><p>首先，因为它们是<a href="https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix" target="_blank" rel="noopener">欧拉角的</a><strong>12种不同</strong> <a href="https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix" target="_blank" rel="noopener">表示/惯例</a>。所以首先您必须同意在与其他人/代码打交道时使用哪种欧拉约定。</p><p>然后，<a href="https://en.wikipedia.org/wiki/Gimbal_lock" target="_blank" rel="noopener">云台锁定</a>。</p><p>仅在必须能够解释旋转时才需要欧拉角。因此仅用于打印或作为用户输入（例如，在Blender中旋转CAD模型）。</p><p>其余时间，应使用旋转矩阵或四元数表示来完成计算。</p><p><code>tvec</code>直接是相机框架和标签框架之间的平移</p><hr><p>利用aruco码可以直接估算姿态的特性，反算出相机姿态（尚未完成）</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200803112936.png" alt=""><br><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200803112937.png" alt=""></p><p>引用：[1]李智猛. 基于WebGL的场景识别视觉定位系统研究[D].杭州师范大学,2020.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;室内定位&quot;&gt;&lt;a href=&quot;#室内定位&quot; class=&quot;headerlink&quot; title=&quot;室内定位&quot;&gt;&lt;/a&gt;室内定位&lt;/h1&gt;&lt;p&gt;机器人的室内定位由于卫星导航失效，主要利用机器人底盘 的&lt;code&gt;轮式光电编码器里程记&lt;/code&gt;、&lt;code&gt;惯性测量
      
    
    </summary>
    
    
    
      <category term="opencv" scheme="https://blog.dgut.top/tags/opencv/"/>
    
      <category term="aruco" scheme="https://blog.dgut.top/tags/aruco/"/>
    
      <category term="python" scheme="https://blog.dgut.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>松山湖机器人公司汇总</title>
    <link href="https://blog.dgut.top/2020/07/30/small-car/"/>
    <id>https://blog.dgut.top/2020/07/30/small-car/</id>
    <published>2020-07-30T02:51:42.000Z</published>
    <updated>2020-08-06T09:11:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="松灵机器人"><a href="#松灵机器人" class="headerlink" title="松灵机器人"></a>松灵机器人</h2><p>官方网站：<a href="http://www.agilex.ai/" target="_blank" rel="noopener">http://www.agilex.ai/</a></p><p>固定电话：+86-0769-22892150<br>本部地址：东莞市松山湖中小企业创业园10栋1楼</p><p>邮箱：<a href="mailto:sales@agilex.ai">sales@agilex.ai</a><br>电话：0769-22892150<br>手机：19925374409</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730114812.png" alt=""></p><blockquote><p>松灵机器人有限公司成立于2016年，是国内领先的机器人底盘制造商和移动机器人系统解决方案服务商。 目前，松灵机器人已经拥有通用型UGV、室内小型AGV、线控改装电动车等移动机器人底盘产品，可服务于安防巡检、园区工业、农业灌溉、物流运输、检测勘探、科研教育等各个领域，为全球不同地区的客户提供性能稳定、质量可靠、7*24h售后无忧的可靠服务。</p><p>松灵机器人致力于打造一流的智能制造、智能工业等基础设施，从而实现“让智能机器人进一步解放人类生产力”的伟大愿景。</p></blockquote><h3 id="公司产品概揽"><a href="#公司产品概揽" class="headerlink" title="公司产品概揽"></a>公司产品概揽</h3><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806170643.png" alt=""></p><blockquote><p>松灵拥有领先的线控型底盘研发技术,可生产适用于各类行业应用场景的低慢速UGV线控底盘,包括轮式与履带<br>式两大体系,目前已经覆盖通用、越野、室内、特殊作业4类典型场景。</p></blockquote><h3 id="候选产品"><a href="#候选产品" class="headerlink" title="候选产品"></a>候选产品</h3><h4 id="1-TRACER"><a href="#1-TRACER" class="headerlink" title="1.TRACER"></a>1.TRACER</h4><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730105745.png" alt=""></p><blockquote><p>TRACER作为一款两轮差速AGV，在室内运输领域具有独特的优势，小巧灵活的结构使得它能自由穿梭在各种室内环境，高承载能力及强劲动力搭配使它单次搬运效率有极大的优势，搭配感知系统更能自主运行，成本低、效率高、部署快，是室内运输场景的性价比之王</p></blockquote><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730105723.png" alt=""></p><p><img src= "/img/loading.gif" data-src="http://www.agilex.ai/upload/pics/7/200609111054_2.jpg" alt="img"></p><p><strong>产品特点</strong>：支持Apollo系统（自动驾驶等更高级功能）、预留多种孔位可以搭载摄像头、IMU、路由等设备，附带SDK二次开发能力出色</p><h4 id="2-BUNKER"><a href="#2-BUNKER" class="headerlink" title="2.BUNKER"></a>2.BUNKER</h4><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730105809.png" alt=""></p><blockquote><p>BUNKER采用履带式差速机械机构，具有极强的地形适应能力，专为特殊作业环境设计，具有差速自转、载重能力强、机械损耗小、防护等级高等特点。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730105822.png" alt=""></p><p><img src= "/img/loading.gif" data-src="http://www.agilex.ai/upload/pics/1/200608153653_4.jpg" alt="img"></p><p><img src= "/img/loading.gif" data-src="http://www.agilex.ai/upload/pics/1/200610115053_4.jpg" alt="img"></p><p><strong>产品特点</strong>：具备全地形通行能力，履带设计可以上下楼梯，重心稳定，前进角度可以达到36度，可作为户外机器人底盘选型</p><h4 id="3-SCOUT-MINI四轮差速系列"><a href="#3-SCOUT-MINI四轮差速系列" class="headerlink" title="3.SCOUT MINI四轮差速系列"></a>3.SCOUT MINI四轮差速系列</h4><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806170805.png" alt=""></p><blockquote><p>SCOUT MINI是SCOUT四轮差速底盘系列的一员，继承了SCOUT系列四轮驱动、独立悬挂、差速自转等特点的同时，采用轮毂电机进行全新设计，使得机身体积缩小50%，速度更是达到20Km/H。使用麦克纳姆轮载重可达50KG。该底盘适用于巡检、拍摄等高机动性要求场景，它的小身材可以帮助不同的客户灵活探索未知的大世界。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806170814.png" alt=""></p><h5 id="产品参数"><a href="#产品参数" class="headerlink" title="产品参数"></a>产品参数</h5><table><thead><tr><th align="center">产品</th><th align="center">麦克纳姆轮版本</th><th align="center">越野公路轮版本</th></tr></thead><tbody><tr><td align="center">额定载重</td><td align="center">50KG</td><td align="center">10-15KG（变更）</td></tr><tr><td align="center">最大速度</td><td align="center">10KM/H</td><td align="center">20KM/H</td></tr><tr><td align="center">悬挂形式</td><td align="center">摇臂独立悬架</td><td align="center">前后双横臂独立悬架</td></tr><tr><td align="center">车体重量</td><td align="center">20KG</td><td align="center">20KG</td></tr><tr><td align="center">最小转弯半径</td><td align="center">可原地转弯</td><td align="center">可原地转弯</td></tr><tr><td align="center">长 x 宽 x 高</td><td align="center">625 × 585 × 222（mm ）</td><td align="center">635 × 549 × 248（mm ）</td></tr><tr><td align="center">轴距 (mm)</td><td align="center">475</td><td align="center">460</td></tr><tr><td align="center">轮距（mm）</td><td align="center">540</td><td align="center">450</td></tr><tr><td align="center">充电时间</td><td align="center">1.5h</td><td align="center">1.5h</td></tr><tr><td align="center">价格（裸车）</td><td align="center">RM9880</td><td align="center">RM9499</td></tr></tbody></table><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806152858.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806154046.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806154117.png" alt=""></p><h5 id="产品特点"><a href="#产品特点" class="headerlink" title="产品特点"></a>产品特点</h5><ul><li>四轮驱动，差速自转</li><li>独立悬挂，防撞减震，越野性能强劲</li><li>标准协议，支持二次开发</li><li>速度20Km/H</li><li>支持摄影、手机控制套件</li><li>可选择越野胎或麦克纳姆轮胎</li></ul><h5 id="电气接口"><a href="#电气接口" class="headerlink" title="电气接口"></a>电气接口</h5><p>在 SCOUT MINI(OMNI)尾部简约的设计，所有的电气接口均在尾部。其接口包括电压显示交互模块、扩展接口、电源按键以及充电接口。各个模块在尾部的位置如图所示</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806154139.png" alt=""></p><p>SCOUT MINI(OMNI)配置的航空扩展接口既配置了一组电源也配置了一组<code>CAN 通讯接口</code>。便于使用者可给扩展设备提供电源，以及通讯使用。其具体引脚定义图所示</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806153259.png" alt=""></p><h5 id="产品尺寸"><a href="#产品尺寸" class="headerlink" title="产品尺寸"></a>产品尺寸</h5><p>麦轮版本：长 x 宽 x 高：625 × 585 × 222（mm ）</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806153627.png" alt=""></p><p>公路轮版本：长 x 宽 x 高：635 × 549 × 248（mm ）</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806154226.png" alt=""></p><p>导轨：欧标4040系列</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806155152.JPG" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806160345.PNG" alt=""></p><h5 id="产品介绍页"><a href="#产品介绍页" class="headerlink" title="产品介绍页"></a>产品介绍页</h5><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806155248.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730115140.png" alt=""></p><h2 id="东莞市微宏智能科技有限公司"><a href="#东莞市微宏智能科技有限公司" class="headerlink" title="东莞市微宏智能科技有限公司"></a><strong>东莞市微宏智能科技有限公司</strong></h2><p>公司网站：<a href="http://wheeltec.net/" target="_blank" rel="noopener">http://wheeltec.net/</a></p><p>地址：东莞市松山湖中小科技企业创业园9栋二楼</p><p>电话： 0769-23832342</p><p>邮箱：<a href="mailto:passoni@126.com">passoni@126.com</a></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730105836.png" alt=""></p><blockquote><p>前身是2015年成立（成都市）武侯区平衡小车之家电子元件经营部，是全国领先的自动化教学产品、科研平台供应商，公司拥有“平衡小车之家”“Ballbot”、“Ballplate”、“Waithome”等多个品牌。国内市场我们是领头羊，海外市场份额逐年上升，拥有多个专利和商标（含申请中）。公司和国内大多数工科院校建立长期稳定的合作关系，大部分产品都走进了高校实验室。公司是集研发、设计、生产、销售为一体的科技公司，技术实力十分雄厚，我们的愿景是为包括全国，甚至全球的客户提供卓越的科研教学产品，为每个员工提供学习、成长的机会。</p></blockquote><h3 id="候选产品-1"><a href="#候选产品-1" class="headerlink" title="候选产品"></a>候选产品</h3><h4 id="1-室外无人车"><a href="#1-室外无人车" class="headerlink" title="1.室外无人车"></a>1.室外无人车</h4><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730105900.png" alt=""></p><p><img src= "/img/loading.gif" data-src="http://www.wheeltec.net/upload/202003/1583402194711350.jpg" alt="东莞微宏"></p><p><img src= "/img/loading.gif" data-src="http://www.wheeltec.net/upload/202003/1583402195845286.jpg" alt="东莞微宏"></p><p><img src= "/img/loading.gif" data-src="http://www.wheeltec.net/upload/202003/1583402194406874.jpg" alt="东莞微宏"></p><p>产品特点：载重能力可以达到35KG-85KG，自重20.5KG-22.3KG，可以定制化</p><h4 id="2-麦克纳姆轮小车"><a href="#2-麦克纳姆轮小车" class="headerlink" title="2.麦克纳姆轮小车"></a>2.麦克纳姆轮小车</h4><p><img src= "/img/loading.gif" data-src="http://wheeltec.net/upload/thumb_src/400_400/1583388871.jpg" alt="麦克纳姆轮小车"></p><p><img src= "/img/loading.gif" data-src="http://www.wheeltec.net/upload/202003/1583401417254442.jpg" alt="东莞微宏"></p><p>产品特点：</p><h4 id="3-摆式悬挂无轴承小车"><a href="#3-摆式悬挂无轴承小车" class="headerlink" title="3.摆式悬挂无轴承小车"></a>3.摆式悬挂无轴承小车</h4><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200730105918.png" alt=""></p><h5 id="产品参数-1"><a href="#产品参数-1" class="headerlink" title="产品参数"></a>产品参数</h5><table><thead><tr><th align="center">产品</th><th align="center">摆式悬挂无轴承小车</th></tr></thead><tbody><tr><td align="center">额定载重</td><td align="center">15KG</td></tr><tr><td align="center">最大速度</td><td align="center">1.2M/S</td></tr><tr><td align="center">悬挂形式</td><td align="center">摇臂独立悬架</td></tr><tr><td align="center">车体重量</td><td align="center">6.1KG</td></tr><tr><td align="center">最小转弯半径</td><td align="center">可原地转弯</td></tr><tr><td align="center">长 x 宽 x 高</td><td align="center">400 × 400 × 100（mm ）</td></tr><tr><td align="center">轴距 (mm)</td><td align="center">312</td></tr><tr><td align="center">轮距（mm）</td><td align="center">406</td></tr><tr><td align="center">充电时间</td><td align="center">-</td></tr><tr><td align="center">价格（裸车）</td><td align="center">RM2799-2999（RC遥控）</td></tr></tbody></table><h5 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806160336.png" alt=""></p><h5 id="产品特点-1"><a href="#产品特点-1" class="headerlink" title="产品特点"></a>产品特点</h5><ul><li><p>提供移动平台的完整源码和主控原理图。提供详细的通信协议和开发手册。无超声、无防跌落模块。激光雷达可选（提供地图构</p></li><li><p>铝合金开孔（可定制），方便安装搭载</p></li><li><p>续航能力：30分钟左右</p></li><li><p>最大速度1.2m/s。速度精度0.03m/s。旋转精度0.1rad/s</p></li><li><p>提供移动平台的完整源码和主控原理图。提供详细的通信协议和开发手册。无超声、无防跌落模块。激光雷达可选（提供地图构建）。到手即可用。</p></li></ul><h5 id="电气接口-1"><a href="#电气接口-1" class="headerlink" title="电气接口"></a>电气接口</h5><p>SWD接口、MicroUSB、TTL串口、CAN端口、手柄接口 </p><blockquote><p>公司未有提供详细的数据，本项为估计</p></blockquote><h5 id="产品尺寸-1"><a href="#产品尺寸-1" class="headerlink" title="产品尺寸"></a>产品尺寸</h5><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806160336.png" alt=""></p><p>导轨：欧标2020系列</p><p>产品特点：尺寸：400<em>400mm～1000</em>1000mm；重量：6.1kg；<br>最大负载：15kg（不含自重）<br>可改造程度：铝合金开孔（可定制），方便安装搭载<br>续航能力：30分钟左右；<br>速度：最大速度1.2m/s。速度精度0.03m/s。旋转精度0.1rad/s。<br>功能：提供移动平台的完整源码和主控原理图。提供详细的通信协议和开发手册。无超声、无防跌落模块。激光雷达可选（提供地图构建）。到手即可用。<br>价格：2799元～2999元（无激光雷达款）****</p><h2 id="初步机器人上层建筑构想"><a href="#初步机器人上层建筑构想" class="headerlink" title="初步机器人上层建筑构想"></a>初步机器人上层建筑构想</h2><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200731113235.png"/><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200731113233.png"/><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200731113234.png"/><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200806160345.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;松灵机器人&quot;&gt;&lt;a href=&quot;#松灵机器人&quot; class=&quot;headerlink&quot; title=&quot;松灵机器人&quot;&gt;&lt;/a&gt;松灵机器人&lt;/h2&gt;&lt;p&gt;官方网站：&lt;a href=&quot;http://www.agilex.ai/&quot; target=&quot;_blank&quot; rel=&quot;
      
    
    </summary>
    
    
    
      <category term="机器人" scheme="https://blog.dgut.top/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>你多久没有仰望夜空了</title>
    <link href="https://blog.dgut.top/2020/07/28/night-thinks/"/>
    <id>https://blog.dgut.top/2020/07/28/night-thinks/</id>
    <published>2020-07-28T05:48:10.000Z</published>
    <updated>2020-07-30T06:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>对夜视的一些看法：</p><p>（以下为全彩色夜视仪的实际效果）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728134952.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728134919.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728135034.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728142354.jpg" alt=""><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728142355.jpg" alt=""><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728142356.jpg" alt=""><br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728142357.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728135053.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200728162818.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对夜视的一些看法：&lt;/p&gt;
&lt;p&gt;（以下为全彩色夜视仪的实际效果）&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.gif&quot; data-src=&quot;https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/202
      
    
    </summary>
    
    
    
      <category term="game" scheme="https://blog.dgut.top/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>python利用opencv进行相机标定(完全版)</title>
    <link href="https://blog.dgut.top/2020/07/20/opencv-biaoding/"/>
    <id>https://blog.dgut.top/2020/07/20/opencv-biaoding/</id>
    <published>2020-07-20T06:55:32.000Z</published>
    <updated>2020-07-23T09:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天的低价单孔摄像机(照相机)会给图像带来很多畸变。畸变主要有两种:径向畸变和切想畸变。如下图所示,用红色直线将棋盘的两个边标注出来,但是你会发现棋盘的边界并不和红线重合。所有我们认为应该是直线的也都凸出来了。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720160250.png" alt=""></p><p>在 3D 相关应用中,必须要先校正这些畸变。为了找到这些纠正参数,我们必须要提供一些包含明显图案模式的样本图片(比如说棋盘)。我们可以在上面找到一些特殊点(如棋盘的四个角点)。我们起到这些特殊点在图片中的位置以及它们的真是位置。有了这些信息,我们就可以使用数学方法求解畸变系数。这就是整个故事的摘要了。为了得到更好的结果,我们至少需要 10 个这样的图<br>案模式。</p><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h2 id="拍摄棋盘图"><a href="#拍摄棋盘图" class="headerlink" title="拍摄棋盘图"></a>拍摄棋盘图</h2><p>首先打印下图：<a href="http://120.79.182.159:8000/f/9ad20d5debfb4aa68898/?dl=1" target="_blank" rel="noopener">下载</a> 也可直接保存</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720160635.png" alt=""></p><p>将其固定到一个平面上，使用相机从不同角度，不同位置拍摄（10-20）张标定图。类似这样的：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720160922.png" alt=""></p><p>python调用opencv相机拍照代码（例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">camera=cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    (grabbed, img) = camera.read()</span><br><span class="line">    cv2.imshow(<span class="string">'img'</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'j'</span>):  <span class="comment"># 按j保存一张图片</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        u = str(i)</span><br><span class="line">        firename=str(<span class="string">'./img'</span>+u+<span class="string">'.jpg'</span>)</span><br><span class="line">        cv2.imwrite(firename, img)</span><br><span class="line">        print(<span class="string">'写入：'</span>,firename)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>按<code>j</code>拍摄图片，将会按照顺序批量保存，按<code>q</code>退出程序。</p><hr><h2 id="寻找棋盘图并且标定-检视标定后结果"><a href="#寻找棋盘图并且标定-检视标定后结果" class="headerlink" title="寻找棋盘图并且标定+检视标定后结果"></a>寻找棋盘图并且标定+检视标定后结果</h2><h3 id="利用opencv寻找棋盘"><a href="#利用opencv寻找棋盘" class="headerlink" title="利用opencv寻找棋盘"></a>利用opencv寻找棋盘</h3><p>为了找到棋盘的图案,我们要使用函数 cv2.findChessboardCorners()。我们还需要传入图案的类型,比如说 8x8 的格子或 5x5 的格子等。在本例中我们使用的9×6 的格子。(通常情况下棋盘都是 8x8 或者 7x7)。它会返回角点,如果得到图像的话返回值类型(Retval)就会是 True。这些角点会按顺序排列(从左到右,从上到下)</p><blockquote><p>这个函数可能不会找出所有图像中应有的图案。所以一个好的方法是编写代码,启动摄像机并在每一帧中检查是否有应有的图案。在我们获得图案之后我们要找到角点并把它们保存成一个列表。在读取下一帧图像之前要设置一定的间隔,这样我们就有足够的时间调整棋盘的方向。继续这个过程直到我们得到足够多好的图案。就算是我们举得这个例子,在所有的 14 幅图像中也不知道有几幅是好的。所以我们要读取每一张图像从其中找到好的能用的。</p></blockquote><blockquote><p>除 了 使 用 棋 盘 之 外, 我 们 还 可 以 使 用 环 形 格 子, 但 是 要 使 用 函 数<br>cv2.findCirclesGrid() 来找图案。据说使用环形格子只需要很少的图像<br>就可以了。</p></blockquote><p>在找到这些角点之后我们可以使用函数 cv2.cornerSubPix() 增加准确度。我们使用函数 cv2.drawChessboardCorners() 绘制图案。所有的这些步骤都被包含在下面的代码中了:</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720161939.png" alt=""></p><h3 id="标定"><a href="#标定" class="headerlink" title="标定"></a>标定</h3><p>在得到了这些对象点和图像点之后,我们已经准备好来做摄像机标定了。我们要使用的函数是 cv2.calibrateCamera()。它会返回摄像机矩阵,畸变系数,旋转和变换向量等。</p><h3 id="畸变矫正"><a href="#畸变矫正" class="headerlink" title="畸变矫正"></a>畸变矫正</h3><p>现在我们找到我们想要的东西了,我们可以找到一幅图像来对他进行校正了。OpenCV 提供了两种方法,我们都学习一下。不过在那之前我们可以使用从函数 cv2.getOptimalNewCameraMatrix() 得到的自由缩放系数对摄像机矩阵进行优化。如果缩放系数 alpha = 0,返回的非畸变图像会带有最少量的不想要的像素。它甚至有可能在图像角点去除一些像素。如果 alpha = 1,所有的像素都会被返回,还有一些黑图像。它还会返回一个 ROI 图像,我们可以用来对结果进行裁剪。</p><p>函数:cv2.getOptimalNewCameraMatrix(mtx,dist,(w,h),<code>1</code>,(w,h))中参数<code>1</code>是个坑,</p><p>官方文档给的参数是<code>1</code>但是标定后的结果是一个球形的视角，我查了好久资料最后咨询了大佬才发现这个坑</p><p>这里我们使用cv2.getOptimalNewCameraMatrix(mtx,dist,(w,h),<code>0</code>,(w,h))参数设置为<code>0</code></p><h3 id="畸变到非畸变"><a href="#畸变到非畸变" class="headerlink" title="畸变到非畸变"></a>畸变到非畸变</h3><p>下面代码中</p><ul><li><p>dst1图像使用的是 cv2.undistort() 这是最简单的方法。只需使用这个函数和上边得到的 ROI 对结果进行裁剪</p></li><li><p>dst2图像使用的是remapping 这应该属于“曲线救国”了。首先我们要找到从畸变图像到非畸变图像的映射方程。再使用重映射方程。(代码中有详细用法)</p></li></ul><p>两种效果可以自行对比看看</p><p>纠正前后对比:</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720163140.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720163139.png" alt=""></p><h3 id="反向投影误差"><a href="#反向投影误差" class="headerlink" title="反向投影误差"></a>反向投影误差</h3><p>我们可以利用反向投影误差对我们找到的参数的准确性进行估计。得到的结果越接近 0 越好。有了内部参数,畸变参数和旋转变换矩阵,我们就可以使用 cv2.projectPoints() 将对象点转换到图像点。然后就可以计算变换得到图像与角点检测算法的绝对差了。然后我们计算所有标定图像的误差平均值。(但是本文不需要,所以没有将其写入)</p><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><p>需要的库:<code>opencv-python</code> <code>numpy</code> <code>glob</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找棋盘格角点</span></span><br><span class="line"><span class="comment"># 设置寻找亚像素角点的参数，采用的停止准则是最大循环次数30和最大误差容限0.001</span></span><br><span class="line">criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, <span class="number">30</span>, <span class="number">0.001</span>) <span class="comment"># 阈值</span></span><br><span class="line"><span class="comment">#棋盘格模板规格</span></span><br><span class="line">w = <span class="number">9</span>   <span class="comment"># 10 - 1</span></span><br><span class="line">h = <span class="number">6</span>   <span class="comment"># 7  - 1</span></span><br><span class="line"><span class="comment"># 世界坐标系中的棋盘格点,例如(0,0,0), (1,0,0), (2,0,0) ....,(8,5,0)，去掉Z坐标，记为二维矩阵</span></span><br><span class="line">objp = np.zeros((w*h,<span class="number">3</span>), np.float32)</span><br><span class="line">objp[:,:<span class="number">2</span>] = np.mgrid[<span class="number">0</span>:w,<span class="number">0</span>:h].T.reshape(<span class="number">-1</span>,<span class="number">2</span>)</span><br><span class="line">objp = objp*<span class="number">18.1</span>  <span class="comment"># 18.1 mm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 储存棋盘格角点的世界坐标和图像坐标对</span></span><br><span class="line">objpoints = [] <span class="comment"># 在世界坐标系中的三维点</span></span><br><span class="line">imgpoints = [] <span class="comment"># 在图像平面的二维点</span></span><br><span class="line"><span class="comment">#加载pic文件夹下所有的jpg图像</span></span><br><span class="line">images = glob.glob(<span class="string">'./*.jpg'</span>)  <span class="comment">#   拍摄的十几张棋盘图片所在目录</span></span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> images:</span><br><span class="line"></span><br><span class="line">    img = cv2.imread(fname)</span><br><span class="line">    <span class="comment"># 获取画面中心点</span></span><br><span class="line">    <span class="comment">#获取图像的长宽</span></span><br><span class="line">    h1, w1 = img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    u, v = img.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 找到棋盘格角点</span></span><br><span class="line">    ret, corners = cv2.findChessboardCorners(gray, (w,h),<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 如果找到足够点对，将其存储起来</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"i:"</span>, i)</span><br><span class="line">        i = i+<span class="number">1</span></span><br><span class="line">        <span class="comment"># 在原角点的基础上寻找亚像素角点</span></span><br><span class="line">        cv2.cornerSubPix(gray,corners,(<span class="number">11</span>,<span class="number">11</span>),(<span class="number">-1</span>,<span class="number">-1</span>),criteria)</span><br><span class="line">        <span class="comment">#追加进入世界三维点和平面二维点中</span></span><br><span class="line">        objpoints.append(objp)</span><br><span class="line">        imgpoints.append(corners)</span><br><span class="line">        <span class="comment"># 将角点在图像上显示</span></span><br><span class="line">        cv2.drawChessboardCorners(img, (w,h), corners, ret)</span><br><span class="line">        cv2.namedWindow(<span class="string">'findCorners'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">        cv2.resizeWindow(<span class="string">'findCorners'</span>, <span class="number">640</span>, <span class="number">480</span>)</span><br><span class="line">        cv2.imshow(<span class="string">'findCorners'</span>,img)</span><br><span class="line">        cv2.waitKey(<span class="number">200</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="comment">#%% 标定</span></span><br><span class="line">print(<span class="string">'正在计算'</span>)</span><br><span class="line"><span class="comment">#标定</span></span><br><span class="line">ret, mtx, dist, rvecs, tvecs = \</span><br><span class="line">    cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::<span class="number">-1</span>], <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"ret:"</span>,ret  )</span><br><span class="line">print(<span class="string">"mtx:\n"</span>,mtx)      <span class="comment"># 内参数矩阵</span></span><br><span class="line">print(<span class="string">"dist畸变值:\n"</span>,dist   )   <span class="comment"># 畸变系数   distortion cofficients = (k_1,k_2,p_1,p_2,k_3)</span></span><br><span class="line">print(<span class="string">"rvecs旋转（向量）外参:\n"</span>,rvecs)   <span class="comment"># 旋转向量  # 外参数</span></span><br><span class="line">print(<span class="string">"tvecs平移（向量）外参:\n"</span>,tvecs  )  <span class="comment"># 平移向量  # 外参数</span></span><br><span class="line">newcameramtx, roi = cv2.getOptimalNewCameraMatrix(mtx, dist, (u, v), <span class="number">0</span>, (u, v))</span><br><span class="line">print(<span class="string">'newcameramtx外参'</span>,newcameramtx)</span><br><span class="line"><span class="comment">#打开摄像机</span></span><br><span class="line">camera=cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    (grabbed,frame)=camera.read()</span><br><span class="line">    h1, w1 = frame.shape[:<span class="number">2</span>]</span><br><span class="line">    newcameramtx, roi = cv2.getOptimalNewCameraMatrix(mtx, dist, (u, v), <span class="number">0</span>, (u, v))</span><br><span class="line">    <span class="comment"># 纠正畸变</span></span><br><span class="line">    dst1 = cv2.undistort(frame, mtx, dist, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">    <span class="comment">#dst2 = cv2.undistort(frame, mtx, dist, None, newcameramtx)</span></span><br><span class="line">    mapx,mapy=cv2.initUndistortRectifyMap(mtx,dist,<span class="literal">None</span>,newcameramtx,(w1,h1),<span class="number">5</span>)</span><br><span class="line">    dst2=cv2.remap(frame,mapx,mapy,cv2.INTER_LINEAR)</span><br><span class="line">    <span class="comment"># 裁剪图像，输出纠正畸变以后的图片</span></span><br><span class="line">    x, y, w1, h1 = roi</span><br><span class="line">    dst1 = dst1[y:y + h1, x:x + w1]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#cv2.imshow('frame',dst2)</span></span><br><span class="line">    <span class="comment">#cv2.imshow('dst1',dst1)</span></span><br><span class="line">    cv2.imshow(<span class="string">'dst2'</span>, dst2)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):  <span class="comment"># 按q保存一张图片</span></span><br><span class="line">        cv2.imwrite(<span class="string">"../u4/frame.jpg"</span>, dst1)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">camera.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>代码放到图片相同的文件夹直接运行即可</p><h1 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h1><p>纠正前后:</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720163313.png" alt=""><br><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720163314.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720163140.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200720163139.png" alt=""></p><p>相机标定完成~</p><div class="note success">            <p>success 标定完成的参数:</p>          </div><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>手头上这个相机镜头标定参数</span></div>    <div class="hide-content"><p>每个相机摄像头的情况都不同按需使用</p><p>dist=np.array(([[-0.58650416 , 0.59103816, -0.00443272 , 0.00357844 ,-0.27203275]]))<br>newcameramtx=np.array([[189.076828   ,  0.    ,     361.20126638]<br> ,[  0 ,2.01627296e+04 ,4.52759577e+02]<br> ,[0, 0, 1]])<br>mtx=np.array([[398.12724231  , 0.      ,   304.35638757],<br> [  0.       ,  345.38259888, 282.49861858],<br> [  0.,           0.,           1.        ]])<br>ret: 1.2796736596876943<br>rvecs旋转（向量）外参:<br> [array([[-0.1273159 ],<br>       [ 0.14990368],<br>       [-0.03444583]]), array([[-0.09406134],<br>       [ 0.00311094],<br>       [ 0.03877124]]), array([[ 0.46123299],<br>       [ 0.13606529],<br>       [-0.10644641]]), array([[-0.21371843],<br>       [ 0.19346393],<br>       [ 0.05795452]]), array([[-0.06136152],<br>       [-0.05609094],<br>       [-0.10779057]]), array([[-0.12671277],<br>       [ 0.19181691],<br>       [-0.01144501]]), array([[-0.10065723],<br>       [ 0.11067488],<br>       [-0.00420227]]), array([[-0.25254906],<br>       [ 0.05724545],<br>       [ 0.06326385]]), array([[ 0.06929893],<br>       [ 0.16462152],<br>       [-0.09935668]]), array([[ 0.32955811],<br>       [ 0.22348145],<br>       [-0.08321155]]), array([[ 0.0963841 ],<br>       [-0.05720288],<br>       [ 0.00220535]]), array([[-0.0885636 ],<br>       [-0.03092561],<br>       [ 0.03529275]]), array([[ 0.03313787],<br>       [-0.05300994],<br>       [-0.03433814]]), array([[-0.22302867],<br>       [ 0.18819738],<br>       [-0.03371187]]), array([[-0.19460224],<br>       [ 0.1036492 ],<br>       [ 0.03301566]]), array([[-0.27115415],<br>       [ 0.18957621],<br>       [-0.04709229]]), array([[-0.12627705],<br>       [ 0.0753438 ],<br>       [ 0.0761791 ]]), array([[ 0.15356268],<br>       [-0.02614756],<br>       [ 0.02406217]]), array([[ 0.69316168],<br>       [ 0.19622708],<br>       [-0.18706069]]), array([[-0.09555645],<br>       [ 0.02551495],<br>       [ 0.02218898]]), array([[-0.08255654],<br>       [-0.07209258],<br>       [ 0.04271465]]), array([[ 0.08770757],<br>       [-0.02304098],<br>       [-0.05008243]]), array([[ 0.58513697],<br>       [-0.00604693],<br>       [-0.1598063 ]]), array([[-0.07233849],<br>       [-0.04780769],<br>       [-0.06191515]]), array([[ 0.09651254],<br>       [ 0.02579441],<br>       [-0.00947478]]), array([[ 0.03501638],<br>       [-0.02501282],<br>       [-0.07304343]]), array([[-0.10470468],<br>       [ 0.21112561],<br>       [-0.0983761 ]]), array([[-0.12674786],<br>       [ 0.1432598 ],<br>       [-0.01007719]]), array([[-0.11004829],<br>       [ 0.06968173],<br>       [ 0.05585313]]), array([[-0.41743998],<br>       [ 0.17304611],<br>       [ 0.03084559]]), array([[-0.10236722],<br>       [ 0.01277654],<br>       [-0.03390285]]), array([[0.22726439],<br>       [0.14038084],<br>       [0.01124049]]), array([[-0.15304123],<br>       [ 0.04465005],<br>       [ 0.06240299]])]<br>tvecs平移（向量）外参:<br> [array([[145.08681235],<br>       [-76.17106891],<br>       [699.69778255]]), array([[-183.67717477],<br>       [-163.96393688],<br>       [ 688.85439168]]), array([[104.0920611 ],<br>       [ 23.92271463],<br>       [965.22859587]]), array([[ 15.24948656],<br>       [-54.85109955],<br>       [795.39600843]]), array([[ 198.06011875],<br>       [-175.91815396],<br>       [ 719.52217088]]), array([[  44.04717785],<br>       [-108.51372353],<br>       [ 788.45975705]]), array([[ -26.16828067],<br>       [-188.47275832],<br>       [ 771.99690841]]), array([[-139.14245711],<br>       [-124.82244434],<br>       [ 644.34844619]]), array([[ 95.41419669],<br>       [-22.10474336],<br>       [747.43156932]]), array([[-16.25541066],<br>       [-60.23640891],<br>       [677.13919736]]), array([[-220.34618611],<br>       [ -12.6889694 ],<br>       [ 708.18042632]]), array([[-205.93499674],<br>       [ -95.59986207],<br>       [ 709.15135801]]), array([[253.32869421],<br>       [-65.19615285],<br>       [793.36052372]]), array([[  8.6811058 ],<br>       [-18.70531877],<br>       [786.28091437]]), array([[-135.91340565],<br>       [ -41.83864798],<br>       [ 734.08050232]]), array([[-10.36373957],<br>       [-74.3822385 ],<br>       [775.58055384]]), array([[-181.85146859],<br>       [-162.51644736],<br>       [ 686.77992674]]), array([[-152.68145934],<br>       [ -45.11437087],<br>       [ 742.99524497]]), array([[  72.01815541],<br>       [-174.95234447],<br>       [ 954.17455852]]), array([[-180.90841277],<br>       [-186.78922299],<br>       [ 694.5911876 ]]), array([[-213.22423756],<br>       [-180.87955611],<br>       [ 668.22586979]]), array([[220.45960743],<br>       [ -3.88665195],<br>       [782.2584453 ]]), array([[-118.59571239],<br>       [ -51.01586357],<br>       [ 905.16719607]]), array([[ 213.87203907],<br>       [-198.38786649],<br>       [ 766.26267678]]), array([[197.15909792],<br>       [-11.90335064],<br>       [831.47489862]]), array([[220.76484713],<br>       [-60.95718003],<br>       [760.66883997]]), array([[117.86186858],<br>       [-64.75570632],<br>       [768.97222101]]), array([[ -39.59646337],<br>       [-165.78421993],<br>       [ 736.04088074]]), array([[-123.20719029],<br>       [-164.0644578 ],<br>       [ 743.43485414]]), array([[-19.65524135],<br>       [-69.18741504],<br>       [690.47472849]]), array([[-203.72891175],<br>       [ -20.1545843 ],<br>       [ 718.13434244]]), array([[ 40.16988244],<br>       [-68.66550898],<br>       [795.54461358]]), array([[-104.02162409],<br>       [-101.3265982 ],<br>       [ 762.41231116]])]<br>newcameramtx外参 [[578.70690918   0.         286.56697375]<br> [  0.         768.62420654 341.06051709]<br> [  0.           0.           1.        ]]</p></div></div><h1 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h1><ul><li>cameramtx：相机内参矩阵</li><li>dist：相机畸变参数</li><li>rvec：输出的旋转向量</li><li>tvec：输出的平移矩阵</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天的低价单孔摄像机(照相机)会给图像带来很多畸变。畸变主要有两种:径向畸变和切想畸变。如下图所示,用红色直线将棋盘的两个边标注出来,但是你会发现棋盘的边界并不和红线重合。所有我们认为应该是直线的也都凸出来了。&lt;/p&gt;
&lt;p&gt;&lt;img src= &quot;/img/loading.
      
    
    </summary>
    
    
    
      <category term="opencv" scheme="https://blog.dgut.top/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>python下使用aruco标记进进行检测</title>
    <link href="https://blog.dgut.top/2020/07/15/python-aruco/"/>
    <id>https://blog.dgut.top/2020/07/15/python-aruco/</id>
    <published>2020-07-15T00:51:43.000Z</published>
    <updated>2020-08-19T00:50:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715114612.png" alt=""></p><a id="more"></a><h1 id="ArUco标记"><a href="#ArUco标记" class="headerlink" title="ArUco标记"></a>ArUco标记</h1><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715093858.png" alt=""></p><p>首先什么是aruco标记呢？</p><p>aruco标记是可用于摄像机姿态估计的二进制方形基准标记。它的主要优点是检测简单、快速，并且具有很强的鲁棒性。ArUco 标记是由宽黑色边框和确定其标识符（id）的内部二进制矩阵组成的正方形标记。aruco标记的黑色边框有助于其在图像中的快速检测，内部二进制编码用于识别标记和提供错误检测和纠正。aruco标记尺寸的大小决定内部矩阵的大小，例如尺寸为 4x4 的标记由 16 位二进制数组成。</p><p>通俗地说，aruco标记其实就是一种编码，就和我们日常生活中的二维码是相似的，只不过由于编码方式的不同，导致它们存储信息的方式、容量等等有所差异，所以在应用层次上也会有所不同。由于单个aruco标记就可以提供足够的对应关系，例如有四个明显的角点及内部的二进制编码，所以aruco标记被广泛用来增加从二维世界映射到三维世界时的信息量，便于发现二维世界与三维世界之间的投影关系，从而实现姿态估计、相机矫正等等应用。</p><p>OpenCV中的ArUco模块包括了对aruco标记的创建和检测，以及将aruco标记用于姿势估计和相机矫正等应用的相关API，同时还提供了标记板等等。本次笔记中主要先整理aruco标记的创建与检测。</p><p>首先我们创建aruco标记时，需要先指定一个字典，这个字典表示的是创建出来的aruco标记具有怎样的尺寸、怎样的编码等等内容，我们使用APIgetPredefinedDictionary（）来声明我们使用的字典。在OpenCV中，提供了多种预定义字典，我们可以通过PREDEFINED_DICTIONARY_NAME来查看有哪些预定义字典。而且字典名称表示了该字典的aruco标记数量和尺寸，例如DICT_7X7_50表示一个包含了50种7x7位标记的字典。</p><hr><h1 id="ArUco标记生成器"><a href="#ArUco标记生成器" class="headerlink" title="ArUco标记生成器"></a>ArUco标记生成器</h1><p>在线aruco标记生成器：<a href="http://aruco.dgut.top/" target="_blank" rel="noopener">http://aruco.dgut.top/</a></p><p>（备用）：<a href="https://chev.me/arucogen/" target="_blank" rel="noopener">https://chev.me/arucogen/</a></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715093013.png" alt=""></p><h1 id="在OpenCV中生成ArUco标记"><a href="#在OpenCV中生成ArUco标记" class="headerlink" title="在OpenCV中生成ArUco标记"></a>在OpenCV中生成ArUco标记</h1><h2 id="opencv-python生成aruco标记"><a href="#opencv-python生成aruco标记" class="headerlink" title="opencv-python生成aruco标记"></a>opencv-python生成aruco标记</h2><p>确定好我们需要的字典后，就可以通过API<code>drawMarker()</code>来绘制出aruco标记，其参数含义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 生成aruco标记</span></span><br><span class="line"><span class="comment"># 加载预定义的字典</span></span><br><span class="line">dictionary = cv2.aruco.Dictionary_get(cv2.aruco.DICT_6X6_250)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标记</span></span><br><span class="line">markerImage = np.zeros((<span class="number">200</span>, <span class="number">200</span>), dtype=np.uint8)</span><br><span class="line">markerImage = cv2.aruco.drawMarker(dictionary, <span class="number">22</span>, <span class="number">200</span>, markerImage, <span class="number">1</span>)</span><br><span class="line">cv2.imwrite(<span class="string">"marker22.png"</span>, markerImage)</span><br></pre></td></tr></table></figure><blockquote><p>opencv的aruco模块共有25个预定义的标记词典。每个词典中所有的Aruco标记均包含相同数量的块或位(例如4×4、5×5、6×6或7×7)，且每个词典中Aruco标记的数量固定(例如50、100、250或1000)。</p></blockquote><p><code>cv2.aruco.Dictionary_get()</code>函数会加载<code>cv2.aruco.DICT_6X6_250</code>包含250个标记的字典，其中每个标记都是6×6位二进制模式</p><p><code>cv2.aruco.drawMarker(dictionary, 22, 200, markerImage, 1)</code>中的第二个参数<code>22</code>是aruco的标记id（0～249），第三个参数决定生成的标记的大小，在上面的示例中，它将生成<code>200×200</code>像素的图像，第四个参数表示将要存储aruco标记的对象(上面的<code>markerImage</code>），最后，第五个参数是边界宽度参数，它决定应将多少位（块）作为边界添加到生成的二进制图案中。</p><p>执行后将会生成这样的标记：标记id分别是<code>22</code></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715091518.png" alt=""></p><details><summary>展开所支持的标记字典</summary><pre><code>展开查看的内容;DICT_4X4_50 Python: cv.aruco.DICT_4X4_50DICT_4X4_100 Python: cv.aruco.DICT_4X4_100DICT_4X4_250 Python: cv.aruco.DICT_4X4_250DICT_4X4_1000 Python: cv.aruco.DICT_4X4_1000DICT_5X5_50 Python: cv.aruco.DICT_5X5_50DICT_5X5_100 Python: cv.aruco.DICT_5X5_100DICT_5X5_250 Python: cv.aruco.DICT_5X5_250DICT_5X5_1000 Python: cv.aruco.DICT_5X5_1000DICT_6X6_50 Python: cv.aruco.DICT_6X6_50DICT_6X6_100 Python: cv.aruco.DICT_6X6_100DICT_6X6_250 Python: cv.aruco.DICT_6X6_250DICT_6X6_1000 Python: cv.aruco.DICT_6X6_1000DICT_7X7_50 Python: cv.aruco.DICT_7X7_50DICT_7X7_100 Python: cv.aruco.DICT_7X7_100DICT_7X7_250 Python: cv.aruco.DICT_7X7_250DICT_7X7_1000 Python: cv.aruco.DICT_7X7_1000DICT_ARUCO_ORIGINAL Python: cv.aruco.DICT_ARUCO_ORIGINALDICT_APRILTAG_16h5 Python: cv.aruco.DICT_APRILTAG_16h54x4 bits, minimum hamming distance between any two codes = 5, 30 codes</code></pre></details>-----<h2 id="批量生成aruco标记"><a href="#批量生成aruco标记" class="headerlink" title="批量生成aruco标记"></a>批量生成aruco标记</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 生成aruco标记</span></span><br><span class="line"><span class="comment"># 加载预定义的字典</span></span><br><span class="line">dictionary = cv2.aruco.Dictionary_get(cv2.aruco.DICT_6X6_250)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成标记</span></span><br><span class="line">markerImage = np.zeros((<span class="number">200</span>, <span class="number">200</span>), dtype=np.uint8)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">    markerImage = cv2.aruco.drawMarker(dictionary, i, <span class="number">200</span>, markerImage, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    firename=<span class="string">'armark/'</span>+str(i)+<span class="string">'.png'</span></span><br><span class="line">    cv2.imwrite(firename, markerImage);</span><br></pre></td></tr></table></figure><p>在armark文件夹下会生成一系列的6*6 <code>aruco标记</code></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200716102446.png" alt=""></p><hr><h1 id="Aruco标记的检测和定位"><a href="#Aruco标记的检测和定位" class="headerlink" title="Aruco标记的检测和定位"></a>Aruco标记的检测和定位</h1><h2 id="静态检测"><a href="#静态检测" class="headerlink" title="静态检测"></a>静态检测</h2><p>在环境中图像检测Aruco标记，环境中有7个标记</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200716104948.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> cv2.aruco <span class="keyword">as</span> aruco</span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line">frame=cv2.imread(<span class="string">'IMG_3739.jpg'</span>)</span><br><span class="line"><span class="comment">#调整图片大小</span></span><br><span class="line">frame=cv2.resize(frame,<span class="literal">None</span>,fx=<span class="number">0.2</span>,fy=<span class="number">0.2</span>,interpolation=cv2.INTER_CUBIC)</span><br><span class="line"><span class="comment">#灰度话</span></span><br><span class="line">gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment">#设置预定义的字典</span></span><br><span class="line">aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)</span><br><span class="line"><span class="comment">#使用默认值初始化检测器参数</span></span><br><span class="line">parameters =  aruco.DetectorParameters_create()</span><br><span class="line"><span class="comment">#使用aruco.detectMarkers()函数可以检测到marker，返回ID和标志板的4个角点坐标</span></span><br><span class="line">corners, ids, rejectedImgPoints = aruco.detectMarkers(gray,aruco_dict,parameters=parameters)</span><br><span class="line"><span class="comment">#画出标志位置</span></span><br><span class="line">aruco.drawDetectedMarkers(frame, corners,ids)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"frame"</span>,frame)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><blockquote><p>对于每次成功检测到标记，将按从左上，右上，右下和左下的顺序检测标记的四个角点。在C ++中，将这4个检测到的角点存储为点矢量，并将图像中的多个标记一起存储在点矢量容器中。在Python中，它们存储为Numpy 数组。</p><p><code>detectMarkers()</code>函数用于检测和确定标记角点的位置。</p><ul><li>第一个参数<code>image</code>是带有标记的场景图像。</li><li>第二个参数<code>dictionary</code>是用于生成标记的字典。成功检测到的标记将存储在markerCorners中，其ID存储在markerIds中。先前初始化的DetectorParameters对象作为传递参数。</li><li>第三个参数<code>parameters</code>： <code>DetectionParameters</code> 类的对象，该对象包括在检测过程中可以自定义的所有参数；</li><li>返回参数<code>corners</code>：检测到的aruco标记的角点列表，对于每个标记，其四个角点均按其原始顺序返回（从右上角开始顺时针旋转），第一个角是右上角，然后是右下角，左下角和左上角。</li><li>返回<code>ids</code>：检测到的每个标记的 id，需要注意的是第三个参数和第四个参数具有相同的大小；</li><li>返回参数<code>rejectedImgPoints</code>：抛弃的候选标记列表，即检测到的、但未提供有效编码的正方形。每个候选标记也由其四个角定义，其格式与第三个参数相同，该参数若无特殊要求可以省略。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">corners, ids, rejectedImgPoints = aruco.detectMarkers(gray,aruco_dict,parameters=parameters)</span><br></pre></td></tr></table></figure><p>当我们检测到aruco标签之后,为了方便观察,我们需要进行可视化操作,把标签标记出来:使用<code>drawDetectedMarkers（）</code>这个API来绘制检测到的aruco标记，其参数含义如下：</p><blockquote><ul><li>参数image: 是将绘制标记的输入 / 输出图像（通常就是检测到标记的图像）</li><li>参数corners：检测到的aruco标记的角点列表</li><li>参数ids：检测到的每个标记对应到其所属字典中的id,可选（如果未提供）不会绘制ID。</li><li>参数borderColor：绘制标记外框的颜色,其余颜色（文本颜色和第一个角颜色）将基于该颜色进行计算，以提高可视化效果。</li><li>无返回值</li></ul></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aruco.draw<span class="constructor">DetectedMarkers(<span class="params">image</span>, <span class="params">corners</span>,<span class="params">ids</span>,<span class="params">borderColor</span>)</span></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200716105125.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200716111938.png" alt=""><br><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200716111939.png" alt=""><br><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200716111940.png" alt=""></p><h2 id="动态检测"><a href="#动态检测" class="headerlink" title="动态检测"></a>动态检测</h2><p>利用摄像头进行一个实时动态监测aruco标记并且估计姿势，摄像头的内参需要提前标定，如何标定请看我<a href="https://blog.dgut.top/2020/07/20/opencv-biaoding/">另一篇文章</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> cv2.aruco <span class="keyword">as</span> aruco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mtx = np.array([</span></span><br><span class="line"><span class="comment">#         [2946.48,       0, 1980.53],</span></span><br><span class="line"><span class="comment">#         [      0, 2945.41, 1129.25],</span></span><br><span class="line"><span class="comment">#         [      0,       0,       1],</span></span><br><span class="line"><span class="comment">#         ])</span></span><br><span class="line"><span class="comment"># #我的手机拍棋盘的时候图片大小是 4000 x 2250</span></span><br><span class="line"><span class="comment"># #ip摄像头拍视频的时候设置的是 1920 x 1080，长宽比是一样的，</span></span><br><span class="line"><span class="comment"># #ip摄像头设置分辨率的时候注意一下</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># dist = np.array( [0.226317, -1.21478, 0.00170689, -0.000334551, 1.9892] )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#相机纠正参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dist=np.array(([[-0.51328742,  0.33232725 , 0.01683581 ,-0.00078608, -0.1159959]]))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># mtx=np.array([[464.73554153, 0.00000000e+00 ,323.989155],</span></span><br><span class="line"><span class="comment">#  [  0.,         476.72971528 ,210.92028],</span></span><br><span class="line"><span class="comment">#  [  0.,           0.,           1.        ]])</span></span><br><span class="line">dist=np.array(([[<span class="number">-0.58650416</span> , <span class="number">0.59103816</span>, <span class="number">-0.00443272</span> , <span class="number">0.00357844</span> ,<span class="number">-0.27203275</span>]]))</span><br><span class="line">newcameramtx=np.array([[<span class="number">189.076828</span>   ,  <span class="number">0.</span>    ,     <span class="number">361.20126638</span>]</span><br><span class="line"> ,[  <span class="number">0</span> ,<span class="number">2.01627296e+04</span> ,<span class="number">4.52759577e+02</span>]</span><br><span class="line"> ,[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">mtx=np.array([[<span class="number">398.12724231</span>  , <span class="number">0.</span>      ,   <span class="number">304.35638757</span>],</span><br><span class="line"> [  <span class="number">0.</span>       ,  <span class="number">345.38259888</span>, <span class="number">282.49861858</span>],</span><br><span class="line"> [  <span class="number">0.</span>,           <span class="number">0.</span>,           <span class="number">1.</span>        ]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX <span class="comment">#font for displaying text (below)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#num = 0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    h1, w1 = frame.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 读取摄像头画面</span></span><br><span class="line">    <span class="comment"># 纠正畸变</span></span><br><span class="line">    newcameramtx, roi = cv2.getOptimalNewCameraMatrix(mtx, dist, (h1, w1), <span class="number">0</span>, (h1, w1))</span><br><span class="line">    dst1 = cv2.undistort(frame, mtx, dist, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">    x, y, w1, h1 = roi</span><br><span class="line">    dst1 = dst1[y:y + h1, x:x + w1]</span><br><span class="line">    frame=dst1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)</span><br><span class="line">    parameters =  aruco.DetectorParameters_create()</span><br><span class="line">    dst1 = cv2.undistort(frame, mtx, dist, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    detectMarkers(...)</span></span><br><span class="line"><span class="string">        detectMarkers(image, dictionary[, corners[, ids[, parameters[, rejectedI</span></span><br><span class="line"><span class="string">        mgPoints]]]]) -&gt; corners, ids, rejectedImgPoints</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用aruco.detectMarkers()函数可以检测到marker，返回ID和标志板的4个角点坐标</span></span><br><span class="line">    corners, ids, rejectedImgPoints = aruco.detectMarkers(gray,aruco_dict,parameters=parameters)</span><br><span class="line"></span><br><span class="line"><span class="comment">#    如果找不打id</span></span><br><span class="line">    <span class="keyword">if</span> ids <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        rvec, tvec, _ = aruco.estimatePoseSingleMarkers(corners, <span class="number">0.05</span>, mtx, dist)</span><br><span class="line">        <span class="comment"># 估计每个标记的姿态并返回值rvet和tvec ---不同</span></span><br><span class="line">        <span class="comment"># from camera coeficcients</span></span><br><span class="line">        (rvec-tvec).any() <span class="comment"># get rid of that nasty numpy value array error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#        aruco.drawAxis(frame, mtx, dist, rvec, tvec, 0.1) #绘制轴</span></span><br><span class="line"><span class="comment">#        aruco.drawDetectedMarkers(frame, corners) #在标记周围画一个正方形</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rvec.shape[<span class="number">0</span>]):</span><br><span class="line">            aruco.drawAxis(frame, mtx, dist, rvec[i, :, :], tvec[i, :, :], <span class="number">0.03</span>)</span><br><span class="line">            aruco.drawDetectedMarkers(frame, corners)</span><br><span class="line">        <span class="comment">###### DRAW ID #####</span></span><br><span class="line">        cv2.putText(frame, <span class="string">"Id: "</span> + str(ids), (<span class="number">0</span>,<span class="number">64</span>), font, <span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>,cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">##### DRAW "NO IDS" #####</span></span><br><span class="line">        cv2.putText(frame, <span class="string">"No Ids"</span>, (<span class="number">0</span>,<span class="number">64</span>), font, <span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>,cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示结果框架</span></span><br><span class="line">    cv2.imshow(<span class="string">"frame"</span>,frame)</span><br><span class="line"></span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key == <span class="number">27</span>:         <span class="comment"># 按esc键退出</span></span><br><span class="line">        print(<span class="string">'esc break...'</span>)</span><br><span class="line">        cap.release()</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key == ord(<span class="string">' '</span>):   <span class="comment"># 按空格键保存</span></span><br><span class="line"><span class="comment">#        num = num + 1</span></span><br><span class="line"><span class="comment">#        filename = "frames_%s.jpg" % num  # 保存一张图像</span></span><br><span class="line">        filename = str(time.time())[:<span class="number">10</span>] + <span class="string">".jpg"</span></span><br><span class="line">        cv2.imwrite(filename, frame)</span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715113014.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715113031.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200715113042.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200716120123.png" alt=""></p><h1 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h1><h2 id="相机标定，并且写入文件保存标定文件"><a href="#相机标定，并且写入文件保存标定文件" class="headerlink" title="相机标定，并且写入文件保存标定文件"></a>相机标定，并且写入文件保存标定文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.patches <span class="keyword">as</span> patches</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找棋盘格角点标定并且写入文件</span></span><br><span class="line"></span><br><span class="line">criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, <span class="number">30</span>, <span class="number">0.001</span>) <span class="comment"># 阈值</span></span><br><span class="line"><span class="comment">#棋盘格模板规格</span></span><br><span class="line">w = <span class="number">9</span>   <span class="comment"># 10 - 1</span></span><br><span class="line">h = <span class="number">6</span>   <span class="comment"># 7  - 1</span></span><br><span class="line"><span class="comment"># 世界坐标系中的棋盘格点,例如(0,0,0), (1,0,0), (2,0,0) ....,(8,5,0)，去掉Z坐标，记为二维矩阵</span></span><br><span class="line">objp = np.zeros((w*h,<span class="number">3</span>), np.float32)</span><br><span class="line">objp[:,:<span class="number">2</span>] = np.mgrid[<span class="number">0</span>:w,<span class="number">0</span>:h].T.reshape(<span class="number">-1</span>,<span class="number">2</span>)</span><br><span class="line">objp = objp*<span class="number">18.1</span>  <span class="comment"># 18.1 mm</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 储存棋盘格角点的世界坐标和图像坐标对</span></span><br><span class="line">objpoints = [] <span class="comment"># 在世界坐标系中的三维点</span></span><br><span class="line">imgpoints = [] <span class="comment"># 在图像平面的二维点</span></span><br><span class="line"></span><br><span class="line">images = glob.glob(<span class="string">'./pic/*.jpg'</span>)  <span class="comment">#   拍摄的十几张棋盘图片所在目录</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> fname <span class="keyword">in</span> images:</span><br><span class="line"></span><br><span class="line">    img = cv2.imread(fname)</span><br><span class="line">    <span class="comment"># 获取画面中心点</span></span><br><span class="line"></span><br><span class="line">    h1, w1 = img.shape[<span class="number">0</span>], img.shape[<span class="number">1</span>]</span><br><span class="line">    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">    u, v = img.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 找到棋盘格角点</span></span><br><span class="line">    ret, corners = cv2.findChessboardCorners(gray, (w,h),<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 如果找到足够点对，将其存储起来</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"i:"</span>, i)</span><br><span class="line">        i = i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        cv2.cornerSubPix(gray,corners,(<span class="number">11</span>,<span class="number">11</span>),(<span class="number">-1</span>,<span class="number">-1</span>),criteria)</span><br><span class="line">        objpoints.append(objp)</span><br><span class="line">        imgpoints.append(corners)</span><br><span class="line">        <span class="comment"># 将角点在图像上显示</span></span><br><span class="line">        cv2.drawChessboardCorners(img, (w,h), corners, ret)</span><br><span class="line">        cv2.namedWindow(<span class="string">'findCorners'</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">        cv2.resizeWindow(<span class="string">'findCorners'</span>, <span class="number">640</span>, <span class="number">480</span>)</span><br><span class="line">        cv2.imshow(<span class="string">'findCorners'</span>,img)</span><br><span class="line">        cv2.waitKey(<span class="number">200</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="comment">#%% 标定</span></span><br><span class="line">print(<span class="string">'正在计算'</span>)</span><br><span class="line">ret, mtx, dist, rvecs, tvecs = \</span><br><span class="line">    cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::<span class="number">-1</span>], <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">cv_file=cv2.FileStorage(<span class="string">"camera.yaml"</span>,cv2.FILE_STORAGE_WRITE)</span><br><span class="line">cv_file.write(<span class="string">"camera_matrix"</span>,mtx)</span><br><span class="line">cv_file.write(<span class="string">"dist_coeff"</span>,dist)</span><br><span class="line"><span class="comment"># 请注意，*释放*不会关闭（）FileStorage对象</span></span><br><span class="line"></span><br><span class="line">cv_file.release()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"ret:"</span>,ret  )</span><br><span class="line">print(<span class="string">"mtx:\n"</span>,mtx)      <span class="comment"># 内参数矩阵</span></span><br><span class="line">print(<span class="string">"dist畸变值:\n"</span>,dist   )   <span class="comment"># 畸变系数   distortion cofficients = (k_1,k_2,p_1,p_2,k_3)</span></span><br><span class="line">print(<span class="string">"rvecs旋转（向量）外参:\n"</span>,rvecs)   <span class="comment"># 旋转向量  # 外参数</span></span><br><span class="line">print(<span class="string">"tvecs平移（向量）外参:\n"</span>,tvecs  )  <span class="comment"># 平移向量  # 外参数</span></span><br><span class="line">newcameramtx, roi = cv2.getOptimalNewCameraMatrix(mtx, dist, (u, v), <span class="number">0</span>, (u, v))</span><br><span class="line">print(<span class="string">'newcameramtx外参'</span>,newcameramtx)</span><br><span class="line">camera=cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dist=np.array(([[-0.3918239532375715, 0.1553689004591761, 0.001069066277469635, 2.175204930902934e-06, -0.02850420360197434]]))</span></span><br><span class="line"><span class="comment"># # newcameramtx=np.array([[1.85389837e+04 ,0.00000000e+00, 5.48743017e+02]</span></span><br><span class="line"><span class="comment"># #  ,[  0 ,2.01627296e+04 ,4.52759577e+02]</span></span><br><span class="line"><span class="comment"># #  ,[0, 0, 1]])</span></span><br><span class="line"><span class="comment"># mtx=np.array([[379.1368428730273, 0, 312.1210537268028],</span></span><br><span class="line"><span class="comment">#  [  0, 381.6396537294123, 242.492484246843],</span></span><br><span class="line"><span class="comment">#  [  0.,           0.,           1.        ]])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    (grabbed,frame)=camera.read()</span><br><span class="line">    h1, w1 = frame.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment">#打开标定文件</span></span><br><span class="line">    cv_file = cv2.FileStorage(<span class="string">"camera.yaml"</span>, cv2.FILE_STORAGE_READ)</span><br><span class="line">    camera_matrix = cv_file.getNode(<span class="string">"camera_matrix"</span>).mat()</span><br><span class="line">    dist_matrix = cv_file.getNode(<span class="string">"dist_coeff"</span>).mat()</span><br><span class="line">    cv_file.release()</span><br><span class="line"></span><br><span class="line">    newcameramtx, roi = cv2.getOptimalNewCameraMatrix(camera_matrix, dist_matrix, (u, v), <span class="number">0</span>, (u, v))</span><br><span class="line">    <span class="comment"># 纠正畸变</span></span><br><span class="line">    dst1 = cv2.undistort(frame, camera_matrix, dist_matrix, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">    <span class="comment">#dst2 = cv2.undistort(frame, mtx, dist, None, newcameramtx)</span></span><br><span class="line">    mapx,mapy=cv2.initUndistortRectifyMap(camera_matrix,dist_matrix,<span class="literal">None</span>,newcameramtx,(w1,h1),<span class="number">5</span>)</span><br><span class="line">    dst2=cv2.remap(frame,mapx,mapy,cv2.INTER_LINEAR)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 裁剪图像，输出纠正畸变以后的图片</span></span><br><span class="line">    x, y, w1, h1 = roi</span><br><span class="line">    dst1 = dst1[y:y + h1, x:x + w1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">'dst1'</span>,dst1)</span><br><span class="line">    <span class="comment">#cv2.imshow('dst2', dst2)</span></span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):  <span class="comment"># 按q保存一张图片</span></span><br><span class="line">        cv2.imwrite(<span class="string">"../u4/frame.jpg"</span>, dst1)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">camera.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h2 id="利用标定文件检测aruco标签"><a href="#利用标定文件检测aruco标签" class="headerlink" title="利用标定文件检测aruco标签"></a>利用标定文件检测aruco标签</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> cv2.aruco <span class="keyword">as</span> aruco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#加载相机纠正参数</span></span><br><span class="line">cv_file = cv2.FileStorage(<span class="string">"yuyan.yaml"</span>, cv2.FILE_STORAGE_READ)</span><br><span class="line">camera_matrix = cv_file.getNode(<span class="string">"camera_matrix"</span>).mat()</span><br><span class="line">dist_matrix = cv_file.getNode(<span class="string">"dist_coeff"</span>).mat()</span><br><span class="line">cv_file.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># dist=np.array(([[-0.51328742,  0.33232725 , 0.01683581 ,-0.00078608, -0.1159959]]))</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># mtx=np.array([[464.73554153, 0.00000000e+00 ,323.989155],</span></span><br><span class="line"><span class="comment">#  [  0.,         476.72971528 ,210.92028],</span></span><br><span class="line"><span class="comment">#  [  0.,           0.,           1.        ]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># dist=np.array(([[-0.58650416 , 0.59103816, -0.00443272 , 0.00357844 ,-0.27203275]]))</span></span><br><span class="line"><span class="comment"># newcameramtx=np.array([[189.076828   ,  0.    ,     361.20126638]</span></span><br><span class="line"><span class="comment">#  ,[  0 ,2.01627296e+04 ,4.52759577e+02]</span></span><br><span class="line"><span class="comment">#  ,[0, 0, 1]])</span></span><br><span class="line"><span class="comment"># mtx=np.array([[398.12724231  , 0.      ,   304.35638757],</span></span><br><span class="line"><span class="comment">#  [  0.       ,  345.38259888, 282.49861858],</span></span><br><span class="line"><span class="comment">#  [  0.,           0.,           1.        ]])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX <span class="comment">#font for displaying text (below)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#num = 0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    h1, w1 = frame.shape[:<span class="number">2</span>]</span><br><span class="line">    <span class="comment"># 读取摄像头画面</span></span><br><span class="line">    <span class="comment"># 纠正畸变</span></span><br><span class="line">    newcameramtx, roi = cv2.getOptimalNewCameraMatrix(camera_matrix, dist_matrix, (h1, w1), <span class="number">0</span>, (h1, w1))</span><br><span class="line">    dst1 = cv2.undistort(frame, camera_matrix, dist_matrix, <span class="literal">None</span>, newcameramtx)</span><br><span class="line">    x, y, w1, h1 = roi</span><br><span class="line">    dst1 = dst1[y:y + h1, x:x + w1]</span><br><span class="line">    frame=dst1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    aruco_dict = aruco.Dictionary_get(aruco.DICT_6X6_250)</span><br><span class="line">    parameters =  aruco.DetectorParameters_create()</span><br><span class="line">    <span class="comment">#dst1 = cv2.undistort(frame, mtx, dist, None, newcameramtx)</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    detectMarkers(...)</span></span><br><span class="line"><span class="string">        detectMarkers(image, dictionary[, corners[, ids[, parameters[, rejectedI</span></span><br><span class="line"><span class="string">        mgPoints]]]]) -&gt; corners, ids, rejectedImgPoints</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#使用aruco.detectMarkers()函数可以检测到marker，返回ID和标志板的4个角点坐标</span></span><br><span class="line">    corners, ids, rejectedImgPoints = aruco.detectMarkers(gray,aruco_dict,parameters=parameters)</span><br><span class="line"></span><br><span class="line"><span class="comment">#    如果找不打id</span></span><br><span class="line">    <span class="keyword">if</span> ids <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line"></span><br><span class="line">        rvec, tvec, _ = aruco.estimatePoseSingleMarkers(corners, <span class="number">0.05</span>, camera_matrix, dist_matrix)</span><br><span class="line">        <span class="comment"># 估计每个标记的姿态并返回值rvet和tvec ---不同</span></span><br><span class="line">        <span class="comment"># from camera coeficcients</span></span><br><span class="line">        (rvec-tvec).any() <span class="comment"># get rid of that nasty numpy value array error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#        aruco.drawAxis(frame, mtx, dist, rvec, tvec, 0.1) #绘制轴</span></span><br><span class="line"><span class="comment">#        aruco.drawDetectedMarkers(frame, corners) #在标记周围画一个正方形</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rvec.shape[<span class="number">0</span>]):</span><br><span class="line">            aruco.drawAxis(frame, camera_matrix, dist_matrix, rvec[i, :, :], tvec[i, :, :], <span class="number">0.03</span>)</span><br><span class="line">            aruco.drawDetectedMarkers(frame, corners,ids)</span><br><span class="line">        <span class="comment">###### DRAW ID #####</span></span><br><span class="line">        cv2.putText(frame, <span class="string">"Id: "</span> + str(ids), (<span class="number">0</span>,<span class="number">64</span>), font, <span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>,cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">##### DRAW "NO IDS" #####</span></span><br><span class="line">        cv2.putText(frame, <span class="string">"No Ids"</span>, (<span class="number">0</span>,<span class="number">64</span>), font, <span class="number">1</span>, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>,cv2.LINE_AA)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示结果框架</span></span><br><span class="line">    cv2.imshow(<span class="string">"frame"</span>,frame)</span><br><span class="line"></span><br><span class="line">    key = cv2.waitKey(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key == <span class="number">27</span>:         <span class="comment"># 按esc键退出</span></span><br><span class="line">        print(<span class="string">'esc break...'</span>)</span><br><span class="line">        cap.release()</span><br><span class="line">        cv2.destroyAllWindows()</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> key == ord(<span class="string">' '</span>):   <span class="comment"># 按空格键保存</span></span><br><span class="line"><span class="comment">#        num = num + 1</span></span><br><span class="line"><span class="comment">#        filename = "frames_%s.jpg" % num  # 保存一张图像</span></span><br><span class="line">        filename = str(time.time())[:<span class="number">10</span>] + <span class="string">".jpg"</span></span><br><span class="line">        cv2.imwrite(filename, frame)</span><br></pre></td></tr></table></figure><p>其中<code>yuyan.yaml</code>为保存的标定文件，利用cv2.FileStorage(“yuyan.yaml”, cv2.FILE_STORAGE_READ)及cv_file.getNode(“camera_matrix”).mat()加载</p><p>本文参考：</p><p>1.<a href="https://blog.csdn.net/sinat_17456165/article/details/105649131" target="_blank" rel="noopener">https://blog.csdn.net/sinat_17456165/article/details/105649131</a></p><p>2.<a href="https://www.learnopencv.com/augmented-reality-using-aruco-markers-in-opencv-c-python/" target="_blank" rel="noopener">https://www.learnopencv.com/augmented-reality-using-aruco-markers-in-opencv-c-python/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/usg1024/imgshow/raw/master/img/20200715114612.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="opencv" scheme="https://blog.dgut.top/tags/opencv/"/>
    
      <category term="aruco" scheme="https://blog.dgut.top/tags/aruco/"/>
    
      <category term="python" scheme="https://blog.dgut.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>git的使用firebase+github pagse同时提交博客</title>
    <link href="https://blog.dgut.top/2020/07/14/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.dgut.top/2020/07/14/git%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-14T06:58:34.000Z</published>
    <updated>2020-08-25T06:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714154834.png" alt=""></p><a id="more"></a><p>firebase的访问一直不稳定，所以还是在github pagse上面也同步一份博客的内容吧</p><h1 id="git的使用记录"><a href="#git的使用记录" class="headerlink" title="git的使用记录"></a>git的使用记录</h1><p>感谢一下<a href="https://magidrag0n.github.io/" target="_blank" rel="noopener">@magidrag0n</a>大佬的教学</p><ul><li><p>首先在你的github创立一个名叫：<code>你的github用户名</code>+ <code>github.io</code>的仓库</p><ul><li>我的github用户名叫<code>zengwenjian123</code>所以我建立的仓库名叫：<code>zengwenjian123.github.io</code></li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200714151120.png" alt=""></p></li><li><p>然后命令行进入到博客的文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo </span><br><span class="line"><span class="comment">#进入博客更目录</span></span><br></pre></td></tr></table></figure></li><li><p>安装插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>打开站点配置文件<code>_config</code></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200714151700.png" alt=""></p><ul><li><p>在最下面添加一个函数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">'git'</span></span><br><span class="line">  repo: <span class="string">'https://github.com/ZengWenJian123/ZengWenJian123.github.io'</span></span><br><span class="line">  branch: <span class="string">'master'</span></span><br></pre></td></tr></table></figure><p>这里填入的是你自己的仓库路径</p></li></ul></li></ul><p>  <img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200714151915.png" alt=""></p><ul><li><p>运行设置账户名</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">"you@example.com"</span></span><br><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br></pre></td></tr></table></figure><p>来设置您账号的缺省身份标识</p></li><li><p>然后运行hexo三连：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>提示输入username for github时输入你的github登录邮箱</p><p>提示输入password for github时输入你的github登录密码</p><p>输入指令记住账户和密码（不用每次部署的时候再次输入）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure></li><li><p>你的hexo博客下的<code>public</code>文件夹将会上传到github仓库了</p></li></ul><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714152551.png" alt=""></p><ul><li>现在访问<a href="https://zengwenjian123.github.io/" target="_blank" rel="noopener">https://zengwenjian123.github.io/</a> 将可以访问到你的博客(说好的google firebase真香呢？)</li></ul><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714152824.png" alt=""></p><ul><li>博客部署github pasges完成</li></ul><hr><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>Username for ‘<a href="https://github.com&#39;" target="_blank" rel="noopener">https://github.com&#39;</a>: 输入的是github上的邮箱账号, 而不是github中设置的username, 这是个巨坑!!!<br>Password for ‘https://你的github邮箱@github.com’: 输入github的登录密码,点击enter键即可.</p><p>利用下面的代码记住账户和密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure><hr><h1 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h1><p>设置短命令：</p><p>令在ubuntu的环境下可以使用短命令来执行一键将静态博客页面部署到github</p><p>首先打开你个人目录下的.bashrc隐藏文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment">#把光标移到末尾按’i’键插入一行</span></span><br><span class="line"><span class="built_in">alias</span> gdd=<span class="string">'hexo clean &amp;&amp; hexo g &amp;&amp; hexo d'</span></span><br></pre></td></tr></table></figure><blockquote><p>然后按’Esc’后按’:wq’保存退出</p></blockquote><ul><li><p>最后在终端输入命令生效刚刚的更改就完事了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li></ul><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714153734.png" alt=""></p><p><code>gdd</code>（搞大点）就是短命令名，每当输入<code>gdd</code>将自动执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>部署三连</p><table><thead><tr><th>firebase 托管</th><th><a href="https://usg-cn.web.app/" target="_blank" rel="noopener">https://usg-cn.web.app/</a></th></tr></thead><tbody><tr><td>github 托管</td><td><a href="https://zengwenjian123.github.io/" target="_blank" rel="noopener">https://zengwenjian123.github.io/</a></td></tr></tbody></table><p>这两个blog将会同时更新</p><hr><h1 id="git相应代码"><a href="#git相应代码" class="headerlink" title="git相应代码"></a>git相应代码</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add README.md </span><br><span class="line">git add aruco_positioning_2D/</span><br><span class="line">git status </span><br><span class="line">git commit </span><br><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://gitee.com/usg1024/imgshow/raw/master/img/20200714154834.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="https://blog.dgut.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="git" scheme="https://blog.dgut.top/tags/git/"/>
    
      <category term="hexo" scheme="https://blog.dgut.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客收录百度和谷歌2020.7.14更新</title>
    <link href="https://blog.dgut.top/2020/07/13/google/"/>
    <id>https://blog.dgut.top/2020/07/13/google/</id>
    <published>2020-07-13T14:36:25.000Z</published>
    <updated>2020-07-17T16:57:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客已经搭建成功了一段时间了，并且添加了一些博文，不过看到博客底部的访客人数还是感觉特别寒酸，为了使博客的曝光读提高，所以就考虑主动让百度或者谷歌等搜索引擎收录。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713171218.png" alt=""></p><a id="more"></a><h1 id="首先确认站点是否已经被收录了"><a href="#首先确认站点是否已经被收录了" class="headerlink" title="首先确认站点是否已经被收录了"></a>首先确认站点是否已经被收录了</h1><p>我的博客地址为：<code>usg-cn.web.app</code>所以可以在百度和谷歌输入下面的格式来判断站点是否已经被收录了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:usg-cn.web.app/</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713171516.png" alt=""><br><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713171517.png" alt=""></p><p>百度的没有，谷歌已经收录了</p><blockquote><p>研究了好久，总感觉百度的搜索蜘蛛效果比谷歌的差一点，新网站谷歌很快就收录了，百度要等好久。</p></blockquote><p>站点还没有被收录就继续下列步骤</p><h1 id="安装扩展插件"><a href="#安装扩展插件" class="headerlink" title="安装扩展插件"></a>安装扩展插件</h1><blockquote><p>站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。</p></blockquote><p>在你的hexo博客根目录，用下面2个命令分别安装谷歌、百度所对应的站点地图生成文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><p>在博客目录的_config.yml中添加如下代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动生成sitemap</span></span><br><span class="line"><span class="comment"># sitemap</span></span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure><p>编译你的博客</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>然后你可以看到在你博客下的<code>public</code>目录下生成了<code>sitemap.xml</code>以及<code>baidusitemap.xml</code>文件，这样就大功告成了。<code>sitemap.xml</code>是提交给谷歌的、<code>baidusitemap.xml</code>是提交给百度的。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714082740.png" alt=""></p><p>部署后你分别访问<br><a href="https://usg-cn.web.app/sitemap.xml" target="_blank" rel="noopener">https://usg-cn.web.app/sitemap.xml</a></p><p><a href="https://usg-cn.web.app/baidusitemap.xml" target="_blank" rel="noopener">https://usg-cn.web.app/baidusitemap.xml</a></p><p>看到如下画面就证明已经成功了</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714083125.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714083205.png" alt=""></p><hr><h1 id="验证网站所有权"><a href="#验证网站所有权" class="headerlink" title="验证网站所有权"></a>验证网站所有权</h1><ul><li><a href="https://link.jianshu.com/?t=https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="noopener">Google搜索引擎提交入口</a></li><li><a href="https://link.jianshu.com/?t=http://www.baidu.com/search/url_submit.htm" target="_blank" rel="noopener">百度搜索引擎入口</a></li></ul><blockquote><p><a href="https://link.jianshu.com?t=http://zhanzhang.baidu.com/college/courseinfo?id=267&page=1#h2_article_title3" target="_blank" rel="noopener">为什么要验证网站</a>　　<br>站长平台推荐站长添加主站（您网站的链接也许会使用www 和非 www 两种网址，建议添加用户能够真实访问到的网址），添加并验证后，可证明您是该域名的拥有者，可以快捷批量添加子站点，查看所有子站数据，无需再一一验证您的子站点。<br><a href="https://link.jianshu.com?t=http://zhanzhang.baidu.com/college/courseinfo?id=267&page=1#h2_article_title13" target="_blank" rel="noopener">如何验证网站</a><br>首先如果您的网站已使用了百度统计，您可以使用统计账号登录平台，或者绑定站长平台与百度统计账号，站长平台支持您批量导入百度统计中的站点，您不需要再对网站进行验证。<br>百度站长平台为未使用百度统计的站点提供三种验证方式：<strong>文件验证、html标签验证、CNAME验证</strong>。<br>1.文件验证：您需要下载验证文件，将文件上传至您的服务器，放置于域名根目录下。<br>2.html标签验证：将html标签添加至网站首页html代码的<head>标签与<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="usg的blog" type="application/atom+xml"></head>标签之间。<br>3.CNAME验证：您需要登录域名提供商或托管服务提供商的网站，添加新的DNS记录。<br>验证完成后，我们将会认为您是网站的拥有者。为使您的网站一直保持验证通过的状态，请保留验证的文件、html标签或CNAME记录，我们会去定期检查验证记录。<br>参考链接：<a href="https://www.jianshu.com/p/5e68f78c7791来源：简书" target="_blank" rel="noopener">https://www.jianshu.com/p/5e68f78c7791来源：简书</a></p></blockquote><h2 id="百度："><a href="#百度：" class="headerlink" title="百度："></a>百度：</h2><p>登录百度<a href="https://ziyuan.baidu.com/linksubmit/url" target="_blank" rel="noopener">资源搜索平台</a><code>用户中心</code> &gt; <code>站点管理</code>，点击<code>添加站点</code></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713172043.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713172059.png" alt=""></p><p><code>站点领域</code>随便填一下就好，然后选择<code>文件验证</code>验证你的网站</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713172447.png" alt=""></p><p>下载红框中的<code>验证文件</code>将它拷贝到<code>hexo/themes/next/source</code>文件夹下</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713172723.png" alt=""></p><p>然后更新部署网站，在你的<code>博客域名</code>+<code>/验证文件名</code>看看你不能访问，例如我输入的是这个：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//usg-cn.web.app/baidu_verify_DppfZ4udwW.html</span></span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713173031.png" alt=""></p><p>就证明验证文件放的位置对了，就可以在验证百度站点了（等待10分钟即可认证完成）</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713173131.png" alt=""></p><hr><h2 id="谷歌："><a href="#谷歌：" class="headerlink" title="谷歌："></a>谷歌：</h2><p>谷歌操作比较简单，就是向<a href="https://link.jianshu.com/?t=https://www.google.com/webmasters/tools" target="_blank" rel="noopener">Google站长工具</a>提交sitemap</p><p>登录Google账号，添加了站点验证通过后，选择添加网址前缀：<code>https://usg-cn.web.app/</code></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714082054.png" alt=""></p><p>选择站点，之后在<code>索引</code>——<code>站点地图</code>中就能看到<code>添加/测试站点地图</code>，如下图：</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713173317.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714082345.png" alt=""></p><p>所有都完成了</p><p>接着等上一段时间：我是弄完就去睡觉了，在搜索引擎输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:usg-cn.web.app&#x2F;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714083449.png" alt=""></p><p>完成收录谷歌了～</p><p>百度的：一直显示抓取失败（这个问题困扰了我好久，一直没有解决）不知道是百度的问题还是我的问题，我浏览器一直可以访问到站点地图的，有知道的朋友在评论区讨论讨论！如果成功了再更新</p><p>未完待续～～～～</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200714083611.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客已经搭建成功了一段时间了，并且添加了一些博文，不过看到博客底部的访客人数还是感觉特别寒酸，为了使博客的曝光读提高，所以就考虑主动让百度或者谷歌等搜索引擎收录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/usg1024/imgshow/raw/master/img/20200713171218.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客" scheme="https://blog.dgut.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="https://blog.dgut.top/tags/hexo/"/>
    
      <category term="google" scheme="https://blog.dgut.top/tags/google/"/>
    
  </entry>
  
  <entry>
    <title>博客加速</title>
    <link href="https://blog.dgut.top/2020/07/13/%E5%8D%9A%E5%AE%A2%E5%8A%A0%E9%80%9F/"/>
    <id>https://blog.dgut.top/2020/07/13/%E5%8D%9A%E5%AE%A2%E5%8A%A0%E9%80%9F/</id>
    <published>2020-07-13T05:52:02.000Z</published>
    <updated>2020-07-13T07:19:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>博客加速</p><p>利用cdn进行博客加速（TODO）</p><a id="more"></a><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713135214.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713135318.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;博客加速&lt;/p&gt;
&lt;p&gt;利用cdn进行博客加速（TODO）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="博客加速" scheme="https://blog.dgut.top/tags/%E5%8D%9A%E5%AE%A2%E5%8A%A0%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>基于opencv4.0 pyzbar和python实现二维码实时检测+定位</title>
    <link href="https://blog.dgut.top/2020/07/13/qrde/"/>
    <id>https://blog.dgut.top/2020/07/13/qrde/</id>
    <published>2020-07-13T01:53:35.000Z</published>
    <updated>2020-07-17T16:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1><p>这是我入职以来第一个任务吧，要完成巡检机器人的一个视觉定位功能，目前想的是机器人通过摄像头检测到张贴在室内各个定点位置二维码，通过识别二维码内部的信息和定制二维码的大小，获取到机器人的位置。</p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713114358.png" alt=""></p><a id="more"></a><p>（机器人现在还是冰山一脚，目前很多功能都没有实现，还处于项目的初级阶段）</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>opencv4.0版本也是发布了，以后应该都是用opencv4.0了，现在已经内置了二维码识别模块，但是在写这段代码的时候还是用的是3.0版本，利用了pyzbar模块进行解码</p><p>环境准备：</p><ul><li>opencv4.0（3.0）</li><li>python3任意版本</li><li>pyzbar</li></ul><p>详情可以查看<a href="https://blog.csdn.net/dgut_guangdian/article/details/106860637" target="_blank" rel="noopener">我的csdn</a>里面的内容也差不多</p><h1 id="初步效果"><a href="#初步效果" class="headerlink" title="初步效果"></a>初步效果</h1><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200713100428.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/PMNCHH/cdn@master/2020/07/13/ef0bd27c920cd8184b333429fa86c461.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/PMNCHH/cdn@master/2020/07/13/dd5735262b51b1911dc4fb016865856a.png" alt=""></p><p>这里的话是3个二维码都可以扫描出来，由于qrcode的信息是中文的所以打印在屏幕上会出错请使用<code>matplotlib</code>显示图像。正确信息可以从控制台查看。</p><hr><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> pyzbar <span class="keyword">import</span> pyzbar</span><br><span class="line"><span class="comment">#二维码动态识别</span></span><br><span class="line">camera=cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">camera.set(<span class="number">3</span>,<span class="number">1280</span>) <span class="comment">#设置分辨率</span></span><br><span class="line">camera.set(<span class="number">4</span>,<span class="number">768</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    (grabbed,frame)=camera.read()</span><br><span class="line">    <span class="comment">#获取画面中心点</span></span><br><span class="line">    h1,w1= frame.shape[<span class="number">0</span>],frame.shape[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 纠正畸变（这里把相机标定的代码去除了，各位自行标定吧）</span></span><br><span class="line">    dst = frame</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 扫描二维码</span></span><br><span class="line">    text = pyzbar.decode(dst)</span><br><span class="line">    <span class="keyword">for</span> texts <span class="keyword">in</span> text:</span><br><span class="line">        textdate = texts.data.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        print(textdate)</span><br><span class="line">        (x, y, w, h) = texts.rect<span class="comment">#获取二维码的外接矩形顶点坐标</span></span><br><span class="line">        print(<span class="string">'识别内容:'</span>+textdate)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 二维码中心坐标</span></span><br><span class="line">        cx = int(x + w / <span class="number">2</span>)</span><br><span class="line">        cy = int(y + h / <span class="number">2</span>)</span><br><span class="line">        cv2.circle(dst, (cx, cy), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">8</span>)  <span class="comment"># 做出中心坐标</span></span><br><span class="line">        print(<span class="string">'中间点坐标：'</span>,cx,cy)</span><br><span class="line">        coordinate=(cx,cy)</span><br><span class="line">        <span class="comment">#在画面左上角写出二维码中心位置</span></span><br><span class="line">        cv2.putText(dst,<span class="string">'QRcode_location'</span>+str(coordinate),(<span class="number">20</span>,<span class="number">20</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="comment">#画出画面中心与二维码中心的连接线</span></span><br><span class="line">        cv2.line(dst, (cx,cy),(int(w1/<span class="number">2</span>),int(h1/<span class="number">2</span>)), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="comment">#cv2.rectangle(dst, (x, y), (x + w, y + h), (0, 255, 255), 2)  # 做出外接矩形</span></span><br><span class="line">        <span class="comment">#二维码最小矩形</span></span><br><span class="line">        cv2.line(dst, texts.polygon[<span class="number">0</span>], texts.polygon[<span class="number">1</span>], (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        cv2.line(dst, texts.polygon[<span class="number">1</span>], texts.polygon[<span class="number">2</span>], (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        cv2.line(dst, texts.polygon[<span class="number">2</span>], texts.polygon[<span class="number">3</span>], (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        cv2.line(dst, texts.polygon[<span class="number">3</span>], texts.polygon[<span class="number">0</span>], (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="comment">#写出扫描内容</span></span><br><span class="line">        txt = <span class="string">'('</span> + texts.type + <span class="string">')  '</span> + textdate</span><br><span class="line">        cv2.putText(dst, txt, (x - <span class="number">10</span>, y - <span class="number">10</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.5</span>, (<span class="number">0</span>, <span class="number">50</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    cv2.imshow(<span class="string">'dst'</span>,dst)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):  <span class="comment"># 按q保存一张图片</span></span><br><span class="line">        cv2.imwrite(<span class="string">"./frame.jpg"</span>, frame)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">camera.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>代码直接运行就行，适用于opencv3.x和4.x版本</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目启动&quot;&gt;&lt;a href=&quot;#项目启动&quot; class=&quot;headerlink&quot; title=&quot;项目启动&quot;&gt;&lt;/a&gt;项目启动&lt;/h1&gt;&lt;p&gt;这是我入职以来第一个任务吧，要完成巡检机器人的一个视觉定位功能，目前想的是机器人通过摄像头检测到张贴在室内各个定点位置二维码，通过识别二维码内部的信息和定制二维码的大小，获取到机器人的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/usg1024/imgshow/raw/master/img/20200713114358.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="opencv" scheme="https://blog.dgut.top/tags/opencv/"/>
    
      <category term="python" scheme="https://blog.dgut.top/tags/python/"/>
    
      <category term="qrcode，work" scheme="https://blog.dgut.top/tags/qrcode%EF%BC%8Cwork/"/>
    
  </entry>
  
  <entry>
    <title>感谢永远有歌，把心境道破</title>
    <link href="https://blog.dgut.top/2020/07/13/eason/"/>
    <id>https://blog.dgut.top/2020/07/13/eason/</id>
    <published>2020-07-13T01:36:49.000Z</published>
    <updated>2020-07-17T16:57:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-11Eason-Live-is-so-much-better-with-Music"><a href="#7-11Eason-Live-is-so-much-better-with-Music" class="headerlink" title="7.11Eason Live is so much better with Music"></a>7.11Eason Live is so much better with Music</h2><h2 id="有-了-音-乐-生-活-更-美-好-，Eason"><a href="#有-了-音-乐-生-活-更-美-好-，Eason" class="headerlink" title="有 了 音 乐 生 活 更 美 好 ，Eason."></a>有 了 音 乐 生 活 更 美 好 ，Eason.</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/MagiDrag0n/PicBed/img/Eason.jpg" alt="img"></p><a id="more"></a><p>youtube地址：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/9KBBYv5neMk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>> 今天最幸福的是就是跟早上起来陪陈奕迅看日出，下午陪陈奕迅看日落！<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src= "/img/loading.gif" data-src="https://pics7.baidu.com/feed/6159252dd42a2834ad1f72340f993cec15cebf03.jpeg?token=f80acdd8826a5aff8f7f729a63b40631" alt="img"></p><p>致敬这场疫情中默默奉献的那些人</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;7-11Eason-Live-is-so-much-better-with-Music&quot;&gt;&lt;a href=&quot;#7-11Eason-Live-is-so-much-better-with-Music&quot; class=&quot;headerlink&quot; title=&quot;7.11Eason Live is so much better with Music&quot;&gt;&lt;/a&gt;7.11Eason Live is so much better with Music&lt;/h2&gt;&lt;h2 id=&quot;有-了-音-乐-生-活-更-美-好-，Eason&quot;&gt;&lt;a href=&quot;#有-了-音-乐-生-活-更-美-好-，Eason&quot; class=&quot;headerlink&quot; title=&quot;有 了 音 乐 生 活 更 美 好 ，Eason.&quot;&gt;&lt;/a&gt;有 了 音 乐 生 活 更 美 好 ，Eason.&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/MagiDrag0n/PicBed/img/Eason.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="日常" scheme="https://blog.dgut.top/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo优雅地使用图床</title>
    <link href="https://blog.dgut.top/2020/07/10/hexo-pic/"/>
    <id>https://blog.dgut.top/2020/07/10/hexo-pic/</id>
    <published>2020-07-10T01:35:48.000Z</published>
    <updated>2020-07-17T16:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实很早就接触了Markdown语法了，那是可以追溯到学生时代。在学校实验室的时候需要对一些新来的师弟师妹进行培训，就需要写一些教程文档，那时候就开始利用Markdown+Typora进行教程编写，但是苦于Markdown语法的特殊性使得图片的插入尤为困难，移动文档的时候往往图片会挂掉，这对于我来说就是十分不方便的，所以最后就不了了之，用回office作罢……</p><p>等到了工作的时候，来到东阳光刚刚入职那会师姐就发来一个用Markdown写的教程文档，我眼前一亮，居然文档可以那么优美简洁，加上学生时代早有接触我打起了重拾Markdown的信心，随后便疯狂地爱上了这种<strong>“轻量级标记语言”</strong>。</p><a id="more"></a><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710101818.png" alt=""></p><p>那么怎么解决图片的问题呢？经过简单的查找之后我找到了<code>PicGo</code>+<code>Github(cdn)</code>的强强组合，这样的组合即简单易用又稳定可靠访问速度还比较快，不用担心图片会被删掉。</p><h1 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h1><p>PicGo的主页：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p><p><strong>PicGo：一个有用的快速上传图片并获取图片URL链接的工具</strong></p><p>PicGo本体支持如下图床：</p><ul><li><code>七牛图床</code> v1.0</li><li><code>腾讯云 COS v4\v5 版本</code> v1.1和v1.5.0</li><li><code>又拍云</code> v1.2.0</li><li><code>GitHub</code> v1.5.0</li><li><code>SM.MS V2</code> v2.3.0-beta.0</li><li><code>阿里云 OSS</code> v1.6.0</li><li><code>Imgur</code> v1.6.0</li></ul><p>PicGo的界面：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-2.0.gif" alt="img"></p><p><img src= "/img/loading.gif" data-src="https://user-images.githubusercontent.com/12621342/34242310-b5056510-e655-11e7-8568-60ffd4f71910.gif" alt="picgo-menubar"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710102357.png" alt="picgo的界面截图"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710102504.png" alt=""></p><p>利用这样的小插件的话可以让我们的Markdown文档轻易的插入图片，在线图片特别方便用于分享出去，芜湖，起飞了！</p><p>安装教程：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo</a></p><hr><h1 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h1><p>GitHub想必大家都知道吧！<code>在线程序员交友平台</code>我们就是利用这个平台作为一个稳定可靠的图片保存位置。</p><h2 id="1-登录GitHub创建Repository"><a href="#1-登录GitHub创建Repository" class="headerlink" title="1.登录GitHub创建Repository"></a>1.登录GitHub创建Repository</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710103103.png" alt=""></p><h2 id="2-设置Repository"><a href="#2-设置Repository" class="headerlink" title="2.设置Repository"></a>2.设置Repository</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710103303.png" alt=""></p><ul><li>设置仓库名</li><li>设置为Pubic（重要）如果设置为私人的话就看不到了</li><li>创建仓库</li></ul><h2 id="3-生成一个Token"><a href="#3-生成一个Token" class="headerlink" title="3.生成一个Token"></a>3.生成一个Token</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710103617.png" alt=""></p><p>点开头像的<code>设定值</code></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710103815.png" alt=""></p><p>点开左侧最下面的<code>开发人员设定</code></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710103921.png" alt=""></p><p>点击个人访问令牌</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710104043.png" alt=""></p><p>创建新的<code>Token</code></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710104124.png" alt=""></p><p>填写描述，选择<code>repo</code>,然后点击<code>Generate token</code>按钮</p><blockquote><p>注意：这串token十分重要，记录下来只会显示一次，要好好保存，不能落入其他人手中喔！</p></blockquote><hr><h1 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h1><p><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">下载相应的版本</a></p><p>安装：不会装的看<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">文档</a></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710104609.png" alt=""></p><blockquote><p>设定仓库名的时候，是按照“账户名/仓库名的格式填写”</p><p>分支名统一填写“master”</p><p>将之前的Token黏贴在这里</p><p>存储的路径可以按照我这样子写，就会在repository下创建一个“img”文件夹</p><p>自定义域名的作用是，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上<code>https://raw.githubusercontent.com/用户名/RepositoryName/分支名，</code>，自定义域名需要按照这样去填写</p><p>或者使用cdn加速：</p><p><code>https://cdn.jsdelivr.net/gh/用户名/RepositoryName</code>来进行加速</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710104922.png" alt=""></p><p>这样之后就可以愉快地在文档中加入图片了，同时你的图片也可以在github仓库中查看到</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710142404.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/ZengWenJian123/picBed/img/20200710142534.png" alt=""></p><hr><h1 id="码云Gitee图床"><a href="#码云Gitee图床" class="headerlink" title="码云Gitee图床"></a>码云Gitee图床</h1><p>教程：<a href="https://cychan811.gitee.io/cychan811/2020/07/04/PicGo-gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/" target="_blank" rel="noopener">地址</a></p><p>码云官网：<a href="https://gitee.com/" target="_blank" rel="noopener">地址</a></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/usg1024/imgshow/raw/master/img/20200713212031.png" alt=""></p><p>速度比GitHub更快而且还不会时不时出现无法提交的小bug，但是怎么说呢？码云gitee毕竟是国内的平台，论体量来说比GitHub小很多，也不排除什么时候突然就停止服务或者关闭api了，所以说这个还是用用就行了。<strong>不过速度是真的快，毕竟是本土化的服务器</strong></p><h1 id="一些错误处理"><a href="#一些错误处理" class="headerlink" title="一些错误处理"></a>一些错误处理</h1><ul><li>上传失败：首先检查上传或者剪贴板的东东是否是支持格式的图片，如果确认无误的话可能是PicGo的问题进入<code>PicGo设置</code> <code>设置Server</code>关闭再打开，如果还是不行重启软件可以解决大部分问题。</li><li>最好打开<code>上传前重命名</code>功能，因为有时候可能因为某些图片是中文的，导致错误，打开后可以把图片设置为数字时间格式，这样方便很多。</li><li>剩下的遇到再补充</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实很早就接触了Markdown语法了，那是可以追溯到学生时代。在学校实验室的时候需要对一些新来的师弟师妹进行培训，就需要写一些教程文档，那时候就开始利用Markdown+Typora进行教程编写，但是苦于Markdown语法的特殊性使得图片的插入尤为困难，移动文档的时候往往图片会挂掉，这对于我来说就是十分不方便的，所以最后就不了了之，用回office作罢……&lt;/p&gt;
&lt;p&gt;等到了工作的时候，来到东阳光刚刚入职那会师姐就发来一个用Markdown写的教程文档，我眼前一亮，居然文档可以那么优美简洁，加上学生时代早有接触我打起了重拾Markdown的信心，随后便疯狂地爱上了这种&lt;strong&gt;“轻量级标记语言”&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="https://blog.dgut.top/tags/hexo/"/>
    
      <category term="next" scheme="https://blog.dgut.top/tags/next/"/>
    
      <category term="图床" scheme="https://blog.dgut.top/tags/%E5%9B%BE%E5%BA%8A/"/>
    
      <category term="markdonw" scheme="https://blog.dgut.top/tags/markdonw/"/>
    
  </entry>
  
</feed>
